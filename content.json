{"pages":[{"title":"about","text":"從2019年的九月開始自學前端技術，在這裡紀錄一些學習的心得。最重要的是：要記得寫！！！","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"JS - BMI計算機","text":"DEMO 目標用JavaScript做一個BMI計算機，而且可以顯示過往的測驗結果。這次一邊整理筆記一邊改寫，將當初很多段重複又累贅的地方重寫，心中很感慨，原來我也是有進步的。 預覽 難點：1.顯示結果的圓圈會根據結果數字的狀態變色2.列表的顏色也要跟著變 思考流程：1.先製作一個介面，使用者可以在相應的欄位輸入身高體重，然後按下結果按鈕 2.使用js計算使用者輸入的資料，並且將這些資料以物件的形式，儲存成一個陣列來管理。 3.這個陣列的資料同時也會儲存進local storage中，不過會是以字串的形式 4.處理完的BMI結果會呈現在欄位右方的圓圈，還有BMI狀態。 5.底下會生成一個相應的列表，記載BMI指數, BMI狀態、身高、體重、檢測日期。圓圈以及列表都會根據BMI狀態改變顏色 6.頁尾 7.結果圓圈的右下方有一個重新施測的紐，我想讓它活潑一點，所以想加一個旋轉的小動畫 8.我想要限制列表的數量，讓它不要過長。超過十五筆的話，就從最早的那一條開始刪掉。 9.我想讓列表從最新一筆紀錄開始呈現，而不是最後一筆 10.我想讓中間的列表在使用者第一次打開網頁時隱藏起來，當有紀錄時才開啟 開始動手作1.先製作一個介面，使用者可以在相應的欄位輸入身高體重，然後按下結果按鈕我將網頁分成三個部分，第一個是欄位區，叫header，中間要放檢測紀錄，就叫history，最後是頁尾，就叫footer。 先分好之後，就開始製作欄位。考慮到這個區塊的各個元素要相互對齊，我新增一個div區塊叫做cal，將這個區塊的display設定成flex，然後使用以下語法: 12align-items: center;justify-content: space-evenly; 我之前常常搞不清楚Items和content的區別，為了以防忘記．在這裡寫起來itemsalign - items和justify-items只能作用於單行 content若有多行元素時，就應使用align-content / justify-content 然後，要記得，flex這個屬性必須掛在外容器上!flexbox參考網頁 接下來，因為需要用到js抓取輸入的資料，各個輸入欄位我都下了不同的class，之後按鈕也要做變化，所以也先下了一個class。 1234567var height = document.querySelector(\".height\"); //使用者身高var weight = document.querySelector(\".weight\"); //使用者體重var resultBtn = document.querySelector(\".result-btn\"); //結果按鈕var list = document.querySelector(\".list\"); //歷史列表var his = document.querySelector(\".history\"); //要呈現列表的區塊//有了class，就可以抓取DOM元素，進行接下來JS的操作。 2.使用js計算使用者輸入的資料，並且將這些資料以物件的形式，儲存成一個陣列來管理。為了要儲存並且更好管理將來的資料，我先宣告一個陣列： 12//若是資料庫中有資料，就轉成物件存進Data, 若沒有就創造一個空陣列var data = JSON.parse(localStorage.getItem(\"BMIlist\")) || []; 這個陣列會從資料庫獲得資料，然後把資料轉化成物件儲存在自己裡面。為什麼不能直接宣告空陣列呢？因為我希望使用者在第二次第三次打開這個網頁時，都能看到自己以前的紀錄，所以要讀取資料庫的資料。這個陣列中的物件，我計劃要有以下的屬性： BMIstatus（BMI狀態）, BMIindex(BMI指數), height, weight, time, color 接下來是計算使用者資料。我寫了一個function。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function calculate(e){ //data陣列中的各個屬性處理 //1. 身高, 體重, BMI結果 var h = parseInt(height.value)/100; var w = parseInt(weight.value); var result = w/(h*h); result = result.toFixed(2); console.log(result); var status = \"\"; var color = \"\"; switch (true){ case result &lt;= 18.5: status = \"過輕\"; color = \"#31baf9\"; break; case 18.5 &lt; result &amp;&amp; result &lt;=25: status = \"理想\" color = \"#86d73f\"; break; case 25 &lt; result &amp;&amp; result &lt;=30: status = \"過重\"; color = \"#ff982d\"; break; case 30 &lt; result &amp;&amp; result &lt;=35: status = \"輕度肥胖\"; color = \"#ff6c03\"; break; case 35 &lt; result &amp;&amp; result &lt;=40: status = \"中度肥胖\"; color = '#ff6c03'; break; case 40 &lt; result: status = \"重度肥胖\" color = \"#ff1200\"; break; default: alert('資料有誤'); break; } //獲得當前日期 var date = new Date(); var day = date.getDate(); var month = date.getMonth()+1; var year = date.getFullYear(); //將計算出的資料存入一個物件中 var BMIdata = { height:h, weight:w, BMI:result, BMIstatus: status, time: month + \"-\" + day + \"-\" + year, color: color,}; //將最新的資料插入陣列中第一個，讓列表能從最新一筆開始 data.splice(0, 0, BMIdata); //將新的BMIdata(物件)存進data updateList(data); localStorage.setItem(\"BMIlist\", JSON.stringify(data)); if(data.length &gt; 15){ clear();}; switchBTN();} 一點小提醒：1.我發現如果不寫parseInt的話，height.value傳進來的會是字串而不是數字（我想是因為，.value本來就是抓取文字欄位元素的關係），為了保險起見，兩個需要傳入的變數我都加上parseInt。順帶一提，parseInt是將字串轉換為數字的一個function。 2.為了讓數字容易運算，結果看起來乾淨漂亮，我在result的數字做了toFixed(2)的處理－讓落落長的數字取到剩下小數點後兩位。 3.switch case的使用：原本我以為只能在有特定值時才可以使用，但其實換個角度想 1234if(result &lt;= 18.5){ status = \"過輕\"; color = \"#31baf9\"; } 這個意思不就代表 當result &lt;=18.5這個表達式 === true嗎？所以可以改寫為 1234switch(true){ case result &lt;= 18.5: //some action} 如此一來，物件中的BMIstatus, BMIindex, height, weight都有了，差一個time 在js中要取得當前時間，必須這樣寫： 12345//獲得當前日期 var date = new Date(); var day = date.getDate(); //取得日期 var month = date.getMonth()+1; //取得月份 var year = date.getFullYear(); //取得年分 要先呼叫一個新的Date物件，然後就可以使用下面幾個函示來取得你想要的內容。對了，getMonth()中，月份的計算是從0開始，一月（0)到十二月(11)，所以要是你想要正確的數字的話，你應該要記得加一。（那為什麼日期不也從0開始……？） 12345678var BMIdata = { height:h, weight:w, BMI:result, BMIstatus: status, time: month + \"-\" + day + \"-\" + year, color: color, }; 把物件中的各屬性配上之前寫的變數。 順帶一提，為了避免使用者沒有填入數字或是只寫零，我又加了一個function。 123456789101112resultBtn.addEventListener(\"click\", check); //按下按鈕後，先檢查是否有輸入數字，或是是否有輸入0，無前述狀況再執行計算function check(e){ if(height.value == \"\" || weight.value ==\"\"||height.value ==0 || weight.vaue == 0){ alert(\"數字不正確\"); } else{ calculate(height.value, weight.value); }};//使用者送出的資料會先跑進這個Function裡檢查有沒有零或是根本沒有填入，若是如此就會跳出一個提醒，若是都有填數字就會開始計算 3.這個陣列的資料同時也會儲存進local storage中，不過會是以字串的形式處理好陣列後，我們要來把它新增進資料庫中 1calStorage.setItem(\"BMIlist\", JSON.stringify(data)); 在資料庫中新增一個叫做BMIlist的欄位，把data陣列中的物件字串化後傳進去。這樣一來，當function calculate把資料都計算完，並且把資料儲存進陣列時，資料庫也會一起被更新。 4.底下會生成一個相應的列表，記載BMI指數, BMI狀態、身高、體重、檢測日期。圓圈以及列表都會根據BMI狀態改變顏色 我在做的時候，因為感覺旁邊的結果圓圈比較難，所以先從列表開始做。我寫了一個Function來處理這件事，這個function叫做updateList(data)，括號中間的data實際上跟上面提到的data陣列是不同的東西，之後我們還要再呼叫一次這個Function並且在括號中傳入data陣列。我只是想提醒我自己接下來要傳進去的是什麼東西。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function updateList(data){ //先抓取資料庫中資料 str = \"\"; //跑迴圈, 對每一個data中的元素都做處理 for(var i=0; i&lt; data.length; i++){ his.style.display = \"block\"; let text = ''; //使用一個template function來統一處理html function template(item){ return text =`&lt;li data-num =${i} class = listItem style = 'border-left: 7px ${data[i].color} solid'&gt;&lt;div class = 'BMIstatus'&gt;&lt;span style = 'font-size: 20px'&gt; ${data[i].BMIstatus}&lt;/span&gt;&lt;/div&gt;&lt;div class = 'result'&gt;BMI &lt;span style = 'font-size :20px; margin-left: 10px'&gt;${data[i].BMI}&lt;/span&gt;&lt;/div&gt;&lt;div class = 'weight-kg'&gt;weight&lt;span style = 'font-size :20px;margin-left: 10px'&gt;${data[i].weight}kg&lt;/span&gt;&lt;/div&gt;&lt;div class = 'height-cm'&gt;height&lt;span style = 'font-size :20px; margin-left: 10px'&gt;${data[i].height*100}cm&lt;/span&gt;&lt;/div&gt;&lt;div class = 'test-date'&gt;${data[i].time}&lt;/div&gt;&lt;/li&gt;` } //抓取陣列資料，根據抓到資料的bmistatus分類並列表 switch (data[i].BMIstatus){ case \"過輕\": template(data[i]); break; case \"理想\": template(data[i]); break; case \"過重\": template(data[i]); break; case \"輕度肥胖\": template(data[i]); break; case \"中度肥胖\": template(data[i]); break; case \"重度肥胖\": template(data[i]); break; default: alert('something is wrong!'); break; } str += text; }; list.innerHTML = str;}; 在這邊最重要的做法就是，使用innerHTML來把新增的列表元素加進ul列表中。所以我先設定一個空字串（str）的變數，在跑接下來的迴圈時，會依序加進相應的內容，最後再將這個字串變成html元素塞進ul列表中。 這樣一來，列表就完成了！這個function被放在程式碼最上面（因為我希望使用者一打開網頁時就能出現列表），還有Calculate函式中（這樣有新的資料傳進資料庫時，列表就能馬上更新）。 5. 我想要限制列表的數量，讓它不要過長。超過十五筆的話，就從最早的那一條開始刪掉。列表完成之後，在測試時發現，要是一直增加資料而沒有一個限制的話，列表就會變的落落長。要避免這件事，我決定限制陣列的長度，寫了一個function 123456789 if(data.length &gt; 15){ clear(); };function clear(){ for(var i=0; i&lt; data.length; i++){ data.splice(i, 1); }; localStorage.setItem(\"BMIlist\", JSON.stringify(data));} clear的功能是，把陣列的元素都跑一遍後，從最後那一筆刪掉一筆，然後用修剪過的陣列再更新一次資料庫。之後當陣列大於15時，就呼叫這個函式，把陣列修剪掉。看到這裡你可能覺得很奇怪，把最後那一筆刪掉的話，不就等於把最新的那筆資料刪掉嗎？這一步驟跟下一步驟環環相扣，請看： 6.我想讓列表從最新一筆紀錄開始呈現，而不是最後一筆網頁在這一步已經完成了有七成了吧。看著列表都能一一出現我已經很滿意，但是因為列表是由陣列的0~14開始跑，我想一想覺得不太對勁：最新的資料卻要滑到最下面才能看到，不是很不方便嗎？ 為了解決這個問題，我一開始的解法是使用data.reverse()反轉陣列。讓最後一筆能夠成為陣列第一筆。結果我發現，因為有許多function都在執行這個陣列，一邊反轉的話，另一邊就會出錯。 最後，我發現事情可以不用這麼複雜。 12data.splice(0, 0, BMIdata); splice( x, y, item) x是你想插入的位置，y是你想從那位置之後刪掉的資料數目，item是你想插進去的資料。使用splice，讓新的資料從第零筆插入，成為第零筆就好，最後一筆成為第一筆，原本的倒數第二成為第二筆，如此往後推進。也因此在上一步驟中的迴圈，我把最後一筆刪掉，其實也等於是把最早的刪掉。 其實我在這裡犯過不少愚蠢的錯…… 7.處理完的BMI結果會呈現在欄位右方的圓圈，還有BMI狀態。不知道為什麼，我一直很害怕這個部分，所以我拖到很後面才做。這一步中，我們要把原本的結果按鈕刪掉，然後新增一個會變色的圓圈圈，圈圈中間有BMI指數，還有一個重新開始的小按鈕，圓圈旁邊跟著一段顯示結果的文字。 先寫一個function，叫做switchBTN(){} 接著來刪掉原本的按鈕。 1234var getParent = resultBtn.parentNode;getParent.removeChild(resultBtn);var div = document.createElement(\"div\");div.setAttribute(\"class\", \"show\"); 我先取得按鈕的父元素（ParentNode），然後移除按鈕（remoceChild），接著新增一個div元素，給他一個Class名稱（我已經預先在css中設定好外觀了）。 接下來，因為這個圓圈有一些必須隨著資料變動的要素，所以就再跑一次迴圈，抓取各元素中的特定值（我要找的是bmi指數以及狀態） 接下來主要分兩部分，先寫個函式把接下來會重複的動作統一處理 1234567891011121314151617181920//這個函式其實一直在做一樣的事, 就是根據傳進來的資料, 還有這筆資料的各種屬性來渲染不同的htmlfunction btnHandle(item){ str = \"&lt;p &gt;\"+item.BMI+\"&lt;/p&gt;&lt;p style = 'font-size: 14px;'&gt;BMI&lt;/p&gt;&lt;a href = 'index.html'&gt;&lt;/a&gt;\"; div.innerHTML = str; div.style.color = item.color; div.style.border = `5px solid ${item.color}`; div.style.position = \"relative\"; var a = div.querySelector(\"a\"); a.style.backgroundColor = item.color; getParent.appendChild(div); //將str的字串新增到div元素中，設定css樣式 var p = document.createElement(\"div\"); p.setAttribute(\"class\", \"statusText\") var pStr = `&lt;p&gt; ${item.BMIstatus}&lt;/p&gt;` p.innerHTML = pStr; p.style.color = item.color; div.appendChild(p); } 然後是條件判斷 12345678910111213141516171819202122232425262728switch (data[0].BMIstatus){ case \"過輕\": btnHandle(data[0]); break; case \"理想\": btnHandle(data[0]); break; case \"過重\": btnHandle(data[0]); break; case \"輕度肥胖\": btnHandle(data[0]); break; case \"中度肥胖\": btnHandle(data[0]); break; case \"重度肥胖\": btnHandle(data[0]); break; default: alert('something is wrong!'); break; } 這個功能基本上就完成了。在這裡的做法跟做列表有點像，都使用到一個把字串塞進空字串中，然後創造html元素的做法。不過在這裡我沒有跑for迴圈，而是用switch來判斷當下的狀態，因為前面我把最新的資料都變成第零筆，所以我只要判斷第零筆的BMI狀態就好。 舉上面的例子，假如第零筆（也就是最新這一筆）的BMI狀態是過輕的話，我就在str中放進兩個p段落（一個是指數，一個是小小的bmi字樣）和一個a連結（重新開始的按鈕），這幾個元素的外觀我都在css中設定好了。 把str的HTML元素用innerHTML的方法設定好之後，接下來是根據該狀態來變更顏色。想要用js變更css樣式的話，就先把要變更的元素抓取過來，然後加上.style.color/ .border/….等等css語法。a連結也設定好之後，使用appendChild把這些新增好的元素加進剛剛的Parent node之下，就可以了。 別忘了，還有旁邊的狀態要寫！ 8.頁尾頁尾只有一個Logo要放，但是原本給的logo是透明的，不是這個顏色。我使用了css中的filter來調整，可以上codepen找css filter。 9.結果圓圈的右下方有一個重新施測的紐，我想讓它活潑一點，所以想加一個旋轉的小動畫123456789101112131415161718.show a:hover{ animation: spin 1.5s infinite; transition: ease;}/* 讓按鈕活潑 */@keyframes spin{ 0%{ 動畫的第０格時 transform: rotate(0); } 50%{ 動畫的中間 transform: rotate(360deg); } 100%{ 動畫的結尾 transform: rotate(360deg); }} 我想做的是：圖案旋轉一圈後，停止一下，再開始新的loop。除了要把iteration設定成infinite(無限)之外，因為要有間隔，所以50%和100%時做的是一樣的事，讓它停在原地。 10.我想讓中間的列表在使用者第一次打開網頁時隱藏起來，當有紀錄時才開啟到這裡網頁都完成了，但是當使用者第一次打開這個網頁時，中間的history區域因為沒有內容，會一片空白，我覺得這樣很奇怪，所以想要先把它隱藏起來，等到有資料進入時再出現。 沒想到我在這裡也花了很久！ 我一開始的做法是：把history區塊整個刪掉，先做條件判斷（當Data的長度&gt;=1時)，然後再一一新增回來。但是因為data有兩筆時也會大於一，有三筆時也會大於一，也就是說，只要有新的資料傳進來，這個條件判斷就會永遠成立，那就等於沒有用了！ 最後才靈光一閃 his.style.display = &quot;none&quot;; 我在程式馬最上面加了這一行，代表：「在網頁打開時，history列表是關起來的」，然後在updateList函式中，我才把它打開，這樣在生成列表的時候，history區塊也會跟著出現了。 心得其實距我做完這份作業已經過去幾個月了，那時候剛碰js，做得小心翼翼又戰戰兢兢的，還老是很悲觀地覺得我一定不行。能夠完成真的很開心！而且老實說，我那時的程式碼超冗長，哈哈，這次一邊整理筆記一邊改寫，將當初很多段重複又累贅的地方重寫，心中很感慨，原來我也是有進步的。算是在最近有些停滯又迷惘的日子提供一點新的動力。","link":"/2020/02/03/2020-02-03/"},{"title":"npm指令無法運作","text":"發現問題剛剛正打算繼續寫vue的專案時，要運行伺服器而在終端機使用npm run serve指令時，突然跳出沒看過的錯誤： 123npm : 無法辨識 'npm' 詞彙是否為 Cmdlet、函數、指令檔或可執行程式的名稱。請檢查名稱拼字是否正確，如果包含路徑的話，請確認路徑是否正確，然後再試一次。位於 線路:1 字元:1 接著我在cmd中也試了vue ui指令，也跳錯 1'node' 不是內部或外部命令、可執行的程式或批次檔 / 解決 'node' 不是內部或外部命令，也不是可運行的程序 到底是……！？ 解決四處搜尋了一下，似乎是環境變數跑掉了，讓電腦找不到要執行的檔案。若你也遇到類似問題，可以跟著接下來的步驟。 1.先到控制台，打開系統 2.找到進階系統設定 3.打開之後，選取環境變數 4.要處理的是下方系統變數中的Path 5.設定路徑由於這次我的npm, nodejs, git都出問題，所以把這些安裝後的路徑都填進去 或是你也可以自己輸入這些路徑，不過不同的路徑間要記得用個分號；隔開 6.按下確定後測試一下，總算解決了 ### 為什麼會發生這個問題，我四處搜尋了下，好像都沒有人知道。不過我今天在剛開電腦時跳出git更新，然後就發生這個災難了。不知道有沒有關聯呢？","link":"/2020/02/02/2020-02-02/"},{"title":"Vue - Vee Validate 3 操作方法","text":"目標因為六角的作業需要使用到Vee validate這個套件，可是課程內使用的第二版和目前第三版已經有所差距了，爬文也找不到相關資料，所以按照官網教學自己做了一次。 使用步驟1. 安裝安裝 npm install --save vee-validate 2. import進檔案中import有兩種方法，一種是在main.js中全局import，如此一來所有元件都能使用，還有一種是在要使用的元件中局部import 2.1 全局import123456//位置:main.js (你的vue專案中的進入點)//引入import { ValidationProvider } from 'vee-validate';//啟用Vue.component('ValidationProvider', ValidationProvider); 全局引用後不用在元件中再次引用就可以直接使用了 2.2 局部引用12345678910//位置：你在使用的元件名稱.vueimport { ValidationProvider } from 'vee-validate';export default {//區域元件註冊 components: { ValidationProvider }}; 3.使用vee validate的標籤validationprovider就如同vue註冊後的元件一樣，元件的名稱就會是html標籤，validation provider就是我們要使用的標籤 123456 &lt;validation-provider rules='email' v-slot='{errors}'&gt; 包住 &lt;input type=\"text\" v-model='form.user.email'&gt; &lt;span&gt;{{errors[0]}}&lt;/span&gt; //若輸入有誤時這裡將會跳出錯誤提示 包住&lt;/validation-provider&gt; HTML無法偵測大小寫, 所以使用kebab寫法 使用validation-provider包住要驗證的input，按照需求綁定V-model，官方建議要有v-model讓套件能抓到要驗證的資料，但是你不想使用的話，也能使用prop方式 :value = value 到這時架構就完成了，不過我們還要綁定一些驗證規則(rule)，讓使用者輸入正確的資料。 4.增加驗證規則(rule)驗證規則就是你要規定這些input中必須輸入什麼樣的訊息，例如要填email的欄位就不能讓使用者填電話號碼。Vee validate其實已經內建好許多規則，但我們可以先來看看怎麼自訂規則。 （以下為全局註冊的做法，若你是在元件內註冊，你可以將這些操作換到該元件中） 4.1 引入extend12//位置:main.jsimport { extend } from 'vee-validate'; ##### 4.2 新增規則我們新增一個規則來驗證使用者是否輸入正數 (positive) 1234567891011//位置:main.js //規則名稱 //使用者輸入的值extend('positive', value =&gt; { //驗證條件: 符合的話為true，不作為 if(value &gt;= 0){ return true; };//若是使用者輸入零或是負數導致驗證條件為false, 跳出下列訊息//錯誤訊息: return '必須大於零';}); 4.3 綁定規則在剛剛的html標籤上加上rules link12345&lt;validation-provider rules='positive' v-slot='{errors}'&gt; &lt;input type=\"text\" v-model='form.user.email'&gt; 錯誤訊息 &lt;span&gt;{{errors[0]}}&lt;/span&gt;&lt;/validation-provider&gt; 註：想要套用多種規則時在這裡我們新增一個規則，規定使用者只能輸入偶數 12345678910111213extend('positive', value =&gt; { if(value &gt;= 0){ return true; }; return '必須大於零';});extend('even', value =&gt; { if(value %2 ===0){ return true; }; return '必須是偶數';}); html綁定方法只要在剛剛的positive規則旁邊，用一條直線再加上新的規則名稱就好 1234&lt;validation-provider rules='positive|even' v-slot='{errors}'&gt; &lt;input type=\"text\" v-model='form.user.email'&gt; &lt;span&gt;{{errors[0]}}&lt;/span&gt;&lt;/validation-provider&gt; 此時套用的兩個規則都會生效。 5. 引用vee validate中內建的規則－以email為例veevalidate中內建有許多規則，你可以到node_modules (套件安裝的地方) =&gt; vee validate =&gt; dist =&gt; rules中找到這裡我們以email為例 （以下仍以全域註冊的方式進行） 5.1 在main.js中引入內建的規則因為這裡只需要email，所以引入這個就好 12//位置:main.jsimport { email } from 'vee-validate/dist/rules'; 5.2 建立規則有兩種做法，分為預設訊息與自訂訊息 5.2.1 若你不需要自訂訊息的話，此時會使用預設的訊息 123// 註冊的名稱 該規則extend('email', email); 5.2.1 若你想要跳出自訂的錯誤提示 12345 //註冊的名稱extend('email', { ...email, message: '郵件地址不正確' //自訂的訊息}); 完成了！ 這篇文章使用了官方的教學文件，想要知道更深入的內容請到這邊","link":"/2020/02/12/2020-02-12/"},{"title":"Git 指令","text":"git log 查詢過往commit紀錄(按q退出) git branch 看目前分支 還原前版git checkout 要前往的過去版號四碼git checkout master 確定還原 HEAD 目前所在位置的指標 git branch new_branch_name 新增分支 git branch 查詢目前有的分支, 目前所在分支前面會有星號 git checkout new_branch_name 切換到新增的分支 git checkout master 切回主枝 git status 目前分支的狀態, 檔案修改紀錄 git merge new_branch將新增分支中的更新也套用至master","link":"/2020/02/27/2020-02-27/"},{"title":"javascript核心篇 - 物件 partI","text":"最近在上六角學院的js核心篇，將筆記整理出來跟大家分享。 物件的宣告(推薦)物件實字 Object Literals 123456789101112131415161718192021//value可以是純值, 原始型別, 函式或另一個物件//屬性名稱一定要是字串, 應避免 0:1 var family = { property: value, name:'貓貓家', deposit: 500, members:{ big_cat:'大貓貓', small_cat:'小貓貓' }, food:['fish', 'dryFood'], callFamily: function(){ console.log(this) //這個family物件 }, callAgain: ()=&gt;{ console.log(this) //window物件 } } 物件建構式 12var newFamily = new Object(family)newFamily == family //true 物件的取值、新增和刪除 取值 family.membersfamily[‘members’]使用中括號不只可使用字串方式取值，可以用數字，也可以使用變數方式作取值，甚至在中括號中做運算後再取值 123family['food'][0] //'fish'let a = 0;family.food[a] //'fish' 新增 1234//新增一個屬性叫pet, 值為hamster family.pet='hamster'//新增一個屬性叫mouse, 值為jerry family[\"mouse\"] = 'jerry' 刪除 delete 123456789delete family.fooddelete family['food']//結果name: \"貓貓家\"deposit: 500members: {big_cat: \"大貓貓\", small_cat: \"小貓貓\"}callFamily: ƒ ()callAgain: ƒ () 變數與物件屬性的差異變數無法被刪除，物件的屬性才可以 1234567891011//此時a,b都存在在window物件下//a為變數var a = 1;//b是window物件內的propertyb=2;delete a; //falsedelete b; //true 可被刪除console.log(a) //1 無法被刪除console.log(b) //not defined (被刪除了)","link":"/2020/04/07/js-object-part1/"},{"title":"口罩地圖開發心得","text":"前言口罩地圖 / Rita Ho原始碼 因應這次的疫情，政府在推行實名制口罩購買後有公開藥局口罩庫存的api，在六角的社團看到後就很有興趣，也馬上打開VSCODE來練習，沒想到中間撞牆多次，耗費許多時間，是看了卡斯柏老師的直播才找到方向。 這篇文章就總結一下開發過程中印象深刻或新學習的部分。 使用技術：ajax, vue, leaflet 多資料串接如上文所說，這次的口罩api是由政府公開的，若你也有興趣的話，可以到這裡這裡，格式是json。 接資料的過程並不難，所以不多說過程，感到困難的部分是，當基本功能都開發完後，我決定使用’geolocation’ in navigators來偵測使用者位置並取得使用者附近的藥局。 使用geolocation時，我忽略了接取這個資料的過程也需要時間，我原本使用另一個函式來做資料接到後的處理，並放在vue的mounted hook，結果就是處理資料的函式先被執行，但要被處理的資料根本還沒來。 注意到這個時間差後，最後我採用的是promise這個方法。 12345678910111213141516171819202122232425//取得使用者位置let getUser = () =&gt; { return new Promise((resolve, reject) =&gt; { // return promise if (\"geolocation\" in navigator) { navigator.geolocation.getCurrentPosition(pos =&gt; { let lng = pos.coords.longitude; let lat = pos.coords.latitude; resolve([lng, lat]); this.user.userStat = true; }); } else { this.user.userStat = false; } }); }; //api資料 this.$http.get('https://raw.githubusercontent.com/kiang/pharmacies/master/json/points.json').then((res)=&gt;{ this.data = res.data.features }).then(getUser).then((data)=&gt;{ //取得使用者位置後再做下列行為 this.user.coords = data; this.flyToUser(); this.getNearby(); }); 在ajax部分，我同時使用到口罩的api和geolocation，這兩者在取得資訊速度也不相同，由於我會需要計算與使用者距離的函式，就勢必要確定兩者都取到資料後再做動作，不然會出現錯誤，但也考慮到也許使用者會不想打開位置偵測，考量之後我就用上述的順序來連接資料串接的過程，如此一來就算沒有使用者位置網站也能運行。 關於promise的部分其實我是這次遇到困難才開始研究，也只是先用求有再求好的心態，因此還不算熟悉（當時也搞到凌晨兩點了……），我想上面的程式碼可能也有我沒注意到的錯誤吧。 Leaflet 套件leaflet是一個js的地圖套件，官網，我採用的地圖是openstreetmap也有人開發出與vue適配性更高的Vue2Leaflet。 其實只使用leaflet原始的套件也是可以的，我也不太清楚兩者會有什麼差。 這次是我第一次自己研究套件和官方文檔，但是礙於我的知識有限，有時候根本是有看沒懂，甚至我一開始自己設定地圖的時候，根本不知道程式碼要放在vue的哪個位置。慘。 這次的網站只運用了leaflet最基本的一些功能，但成果我已經很滿意了，以呈現地圖和使用者交互的方面來說，真的不輸google map，另外，openstreetmap的地圖也滿精確的。真的很感謝這些開源又推廣技術的偉大團隊們。 程式碼規劃以前寫程式碼的時候，總是想說先寫再說，有就好，結果回過頭來看寫了很多重複累贅的功能或模板，這些其實都能整合起來。不知道在哪看到的話：「如果發現自己在寫第二遍一樣的東西時，就代表程式碼需要重構(refractor)了」，這次開發時謹記在心，一旦發現現在寫的東西之前好像有類似的，就會研究怎麼重構他，因此這次的成品跟之前相比真的精簡很多，每個功能我自認也都有其存在的理由。也算是有所成長了吧。 不過，永遠都不能愛上自己寫的code!! (出處不明) 在資料結構的規劃上，這次也學習到很多，經過各方觀摩後，這次也嘗試多使用物件的形式來整理資料，也能讓程式碼精簡一些，好像能比較靈活的規劃資料了。 UI規劃這次的版型是自己刻的，也有兼顧響應式，我個人很滿意在PC端的表現，雙欄式讓資料很清楚易懂，但是以現在的社會來說，以手機瀏覽的比重較重，因此在考慮手機版時，我決定讓地圖先呈現，下滑後才是結果列表。一開始的考量是結果列表比較長，文字的地址和圖像的呈現相較起來，後者似乎比較切身易懂。 不過實際使用後，總覺得一開始使用者面對一堆標示可能會搞不清楚狀況。我看到有些人是設定列表隱藏，全螢幕地圖，但問題感覺沒有解決。 另外，由於這次口罩實名制購買的規定挺繁瑣，還有關於圖示的說明，文字量有些多，因此我也不打算放在頁面上，而是需要點擊問號方塊另外打開，不知道這樣的設計夠不夠清楚呢？ 總結以我自己來說，給自己這次的表現90分了，一開始瘋狂撞牆的時候真的很痛苦，質疑自己很多次，但我都沒有放棄，四處找資料找資源，本來我以為自己可能真的不適合，但是只要我不放棄就代表我還是喜歡這件事的，我很高興這次相信了自己。","link":"/2020/02/19/2020-02-19/"},{"title":"陣列常用方法","text":"這是我的陣列方法筆記。不一定詳盡，就給自己做個紀錄。（詞窮） forEach12345678910111213141516171819202122232425262728const people = [ { name: '小明', money: 500 }, { name: '漂亮阿姨', money: 3000 }, { name: '杰倫', money: 60000 }, { name: '老媽', money: Infinity }];// forEach 與 map// 將所有物件增加 icash 有多少金額的欄位// for(let i=0; i&lt; people.length; i++){// console.log(people[i]);// }//通常不會用到people.forEach(function(item, index, array){ console.log(item, index, array);}) map跟forEach很像,但會回傳值 123456789101112//要有一個變數來儲存MAP回傳的值let peopleCash = people.map(function(item, index, array){ //回傳一個物件 //物件中包含該陣列的每一個元素, 在每個元素上再新增一屬性為icash return{ ...item, iCash: item.money +500 } })console.log(peopleCash); 若是沒有使用return, 還是會回傳一個跟原本長度相同的陣列, 但內容會是undefined用map做篩選： 123456789101112131415//若是使用map做篩選const peopleCash = people.map(function(item, index, array){ //篩出金額大於2000的元素 if(item.money &gt;2000){ return item; } })console.log(peopleCash);//outcome 0: undefined1: {name: \"漂亮阿姨\", money: 3000}2: {name: \"杰倫\", money: 60000}3: {name: \"老媽\", money: Infinity} 沒有通過篩選條件的還是會回傳, 值會是undefined, 所以不適合 filter會將通過條件的才回傳filter和map都要傳入一個函式, 參數為item(各元素), index(索引值), array(要傳入的陣列) 12345678const filteredPeople = people.filter(function(item, index, array){ //會回傳值為true的元素, 是一個陣列 // return true; if(item.money &gt;2000){ return true; }});console.log(filteredPeople); find找到的資料只會回傳第一個符合條件的, 會按照原本的格式回傳 1234567891011// find// 1. 找到金額 = 500 的物件// 2. 找到 &gt; 5000 的物件const findPeople = people.find(function(item, index, array){ //找到的資料只會回傳第一個符合條件的, 會按照原本的格式回傳 if(item.money &gt;2000){ return true; }});console.log(findPeople); //{name: \"漂亮阿姨\", money: 3000} every設定一個檢查條件若是全部元素都通過, 就回傳true, 反之就false 123456const ans = people.every(function(item, i){ //設定一個檢查條件 //若是全部元素都通過, 就回傳true, 反之就false return item.money &gt; 50;});console.log(ans); //每個元素都有超過50, true (布林) some設定一個檢查條件若是有其中一個元素都通過, 就回傳true, 反之就false 123456789// some// 1. 是否有物件超過 10000 元// 2. 是否有物件持有金額少於 300元const some = people.some(function(item, i){ //設定一個檢查條件 //若是有其中一個元素都通過, 就回傳true, 反之就false return item.money &gt; 50000;});console.log(some); //有其中幾個超過50000, true (布林) reduce設定一個檢查條件若是有其中一個元素都通過, 就回傳true, 反之就false 123456789101112131415161718192021// reduce// 去除掉老媽，請問剩下的人有多少錢？// 會回傳,適合用於數字運算 //前一個(沒有前一個就逗號後補零)// const newNum = people.reduce(function(prev, item, index ){// console.log(prev); //0// return prev +500; //500 1000 1500// }, 0) //0會被帶入prev// const newNum = people.reduce(function(prev, item, index ){// console.log(prev); //0// return prev +500; //600 1100 1600// }, 100)//加總const newNum = people.reduce(function(prev, item, index){ console.log(prev); //0 return prev + item.money; //0 500 3500 63500 (最後一個數字為加總)}, 0);console.log('newNum' + newNum); //63500 沒了","link":"/2020/04/02/js-array/"},{"title":"Hex post 開發心得","text":"Demo - Hex post原始碼 - github 六角舉辦的鼠年全馬挑戰賽在今年的2/3號開始了，活動內容是要每周寫一篇技術文章，為期一年，活動開始後六角釋出了官方的文章連結api，可以查看所有參加者的文章連結，這次使用了這個api做一個文章彙總網站，取名叫hex post。 構想在我打算做這份作品之前，其實已經有些人使用這份API完成過類似作品了，綜觀這些作品，大多是用列表呈現，比較著重在文章和更新順序，於是我就思考我可以做什麼跟這些作品區別開來。我開始想像如果我要做這件事，是想要什麼效果？突然我想到當我在瀏覽別人的技術部落格時，常常會是零留言、零拍手，每個人一定都很希望自己的作品有人看到、有人欣賞，因此我決定要做一份類似報章雜誌類的網站，並且希望這個網站能夠為大家提供更好的曝光。 既然決定了網站的方向，心裡也有了大概的輪廓，我參考了一些新聞網站、還有Medium的布局，畫了一些示意圖。 預期的功能有： 首頁有廣告最新文章的欄位 首頁有廣告最新更新作者的欄位 首頁也可以查看之前收藏的文章 可以收藏文章/作者 可以搜尋文章/作者 能查看收藏作者的最新文章 可以瀏覽歷史紀錄 功能規劃上以「讀」為本位，一切考量都是在思考讀者可以怎麼樣接觸更多文章，所以規劃上以讓讀者好親近好使用為主。 其實我也知道只要功能性做出來，這就是一份不錯的專案了，但我還是無法捨棄追求好看的版面 這份示意圖大概是第三份吧，原本我還打算要做的色彩繽紛一點，但是怎麼配色都覺得好俗好醜好浮誇好累喔，最後有點自暴自棄的用小畫家拉，懶得上色所以先用黑灰色示意，沒想到覺得滿好看的，顏色就這樣定下了。 可以看的出來本來我想要做的更複雜的，可以收藏文章、查看瀏覽紀錄、不管哪個頁面都有可以廣告文章的版面，想要讓文章隨時都能出現在使用者面前。 實作本次使用Vue，因為想做的更複雜，也使用了Vue Route來做多頁面，跟原生的JS相比，Vue真的讓資料結構與變化更好操作。（如果是原生JS我真的完全不知道怎麼做….要反省) 我認為這次最難的部分大概是資料間的交互以及同步吧，因為我有使用到local storage來儲存收藏清單，另外，資料的加載是每個頁面打開時才動作，因此每次打開都要重新跟local storage同步一次，而每個頁面的資料結構可能不太一樣（例如：文章頁面和首頁的收藏功能取得的資料可能不太一樣），我承認我在一開始沒有好好規劃這部分，也讓作業在一些不該變得複雜的地方複雜了起來，花很多時間在統一格式以及檢查。 說一個有點好笑的事情：其實整個作品裡我最喜歡的是文章頁的那兩個頁籤，那個圓弧、那個顏色填滿的感覺、搭配有點圓圓的文字、怎麼那麼可愛…… 另外，也調整很多初步layout上的東西，在文章頁面和作者頁面少了廣告欄位，因為實際使用上覺得會太過拖沓。重新思考很多版面的編排，還有怎麼增加使用上的便利性。像是搜索這個功能，一開始只想說簡單用個string.includes就好，後來覺得應該再加上排除大小寫，有很多這樣子的時刻：好不容易刻出來一個功能，但怎麼看都不滿意，這邊應該要如何如何，那邊應該要這樣這樣…… 可改進的地方網站上線之後有貼到六角的社群，得到一些寶貴的意見，大部分是版面的安排和css的小動畫，可以得到別人的回饋真的是很棒的事，而且大家還仔細的看了我的原始碼給出建議，真的很感謝。 這次也是我第一次使用scss，不過我課程才上到一半，很多觀念都還不會，因此寫得亂七八糟（笑）。 也有請六角的助教替我code review，沒有被發現什麼可怕的錯誤，只是一些排版上的小建議，我本來超擔心的哈哈哈哈哈哈哈哈。但我其實還沒有修…… 還有一點比較遺憾，是沒有做出收藏作者的功能，我本來滿期待做這個的，但是製作這個專案的時間超乎我預期，覺得自己應該再往前進了，就先擱下不做，也許在鐵人賽進行的這一年我會把它完成。 另外，在ios上瀏覽的體驗有些不如我預期，因為我沒有清除掉ios上的樣式，導致按鈕和選單出現錯位，但我嘗試了查到的一些方法都沒有效果，六角的助教也說沒有發現這問題，謎。 感想這樣寫下來，好像沒有寫到什麼很技術的東西（笑），即使經過這次專案，好像也不能說對vue更熟了些（？），有很多很多需要再改進的地方，也有很多想嘗試的功能最後沒用到（像是謎之slot），不過也學到很多小技巧，更有收穫的是在製作過程中的思考，不是只把這個網站當作一個作業，而是一個產品，它有符合我的想像嗎？有符合我的初衷嗎？另外，想像使用者會怎麼使用它，也許會遇到什麼問題，也許會欣賞其中的那些細節，就會讓人想花更多時間打磨，這是一個很有趣的過程，剛好在要準備Vue最終作業之前，給自己打氣一下。 期望每個人在創作時都有人欣賞，閱讀時都有所收穫！","link":"/2020/03/10/hex-post/"},{"title":"JavaScript中的括號問題","text":"之前在上一堂線上課程時，發現js在執行函式時有無括號的不同，有一位同學給出的解答我覺得很有幫助，翻譯出來給大家參考。 這篇文章譯自課程The Modern JavaScript Bootcamp中的一篇問答。這堂課雖然號稱開給初心者，但後半都是實作項目，雖然很有趣，但會碰到一些較進階的問題，且老師不一定有時間解答，而且有時候老師回答的超級簡短，若是沒辦法搞清楚，可能會懵懵懂懂不知道自己在幹嘛。 前情提要這份實作是要做出一個使用者在填寫搜尋欄位時，欄位會綁定監聽器，將輸入值與API的資料匹配．自動跳出符合結果的Autocomplete小工具，其中為了讓Ajax請求送出的頻率不要太過頻繁，原課程中使用了一個名為debounce的函式，這個函式中包含一個負責根據欄位輸入來送出請求的閉包。接著在input欄位綁定監聽，執行debounce。但是為什麼事件發生時執行的不是debounce而是裡面的閉包？造成很多人的疑問。 以下原文搭配中文譯文，因為提及該課堂作業的一些程式碼，為了讓讀者好理解，做過一些刪減 正文When you initially load up your JS code, the code gets evaluated by the JS Engine.在程式碼執行之前，會被js的引擎評估 To a JS parser, the two lines are different: each producing unique outcome對js的編譯器來說，以下這兩行是不同的，產生的結果也完全不同 inputValue.addEventListener(&quot;input&quot;, debounce(onInput, 500)); inputValue.addEventListener(&quot;input&quot;, debounce); The first line tells the ENGINE to invoke the debounce function immediately and replace it with its result.第一行告訴引擎直接執行這個函式，並且將它替換成它的結果 the anonymous closure is the result it produces, which ,as Stephen states above, gets repeatedly executed, each time a user types something into the input field結果就是它內部所含的匿名閉包，正如stephen（講者）所說，這個閉包會在使用者輸入欄位時被重複執行 The second line just references a function name that shall be executed when the input event is triggered.第二行則是說當input事件發生時在執行這個函式 Here’s a little demo :這裡是一點小示範 Imagine you have two, typical function declarations that you wish to assign to a particular object : ROBOT in our example :想像你有兩個宣告方式一樣的函式，你想將這兩個函式分派給一個物件：robot 1234567891011121314151617181920212223242526272829303132//宣告 function identity(){ return this } //宣告 function whoAmI(){ return ` Who am I ? ${name} `} //物件 let robot= { name: \" I am a Robot\", identity:identity, //沒有括號 whoAmI:whoAmI() //有括號 } console.log(robot.identity());console.log(robot.whoAmI()); Pay close attention how the two functions are being assigned/ referenced inside of the robot object.請注意看看這兩個在robot物件中是怎麼被指派的。 when the robot has its methods invoked , one of those methods - robot.whoAmI() - produces an error.當robot使用這兩個函式時，其中一個－robot.whoAmI()出錯了 As you can see from the image above, robot.whoAmI no longer points to the function .如你所見，此時robot.whoAmI不再指向一個函式 And that is correct with accordance to this line :但是根據這行程式碼, 這其實是正確的結果 whoAmI:whoAmI() The line tells the ENGINE to invoke the whoAmI function immediately and replace it with its result.這一行程式碼告訴引擎馬上執行這個函式, 並且用它產生的結果替換它 而whoami產生的結果就是回傳一個字串，而字串並不是一個函式，所以也無法被呼叫。 結論：inputValue.addEventListener(&quot;input&quot;, debounce(onInput, 500));而在原文的程式碼中，debounce函式在addEventListener被掛上時，其實就執行過了，它會被替換成裡面的閉包函式，這個函式才是監聽器被觸發時真正被呼叫的，也會接收到event。 也就是說，js的編譯器在遇到括號時就會馬上執行，這也是立即執行函式(IIFE)的基礎。","link":"/2020/03/26/js-parentheses/"},{"title":"正規表達式 - 符號&常用方法","text":"最近發現自己還滿常用到正規表達式的，每次都是上網找然後複製貼上，因為看起來像亂碼一樣每次看都覺得頭痛，今天就參考MDN來學習一下，放在這裡讓自己以後都可以查。 寫法const regExp = / regExp /用兩個斜線包住 或是使用正規表達式的建構函式 const regExp = new RegExp(&quot;regexp&quot;) 簡易模式找到的直接匹配所構成的，也就是結果會完全匹配要搜尋的字串 例：尋找abc“Let’s sing abc song!” “grab crab” 要尋找”abc”時，第一個句子會匹配成功，因為在這個句子中有abc，沒有斷開也沒有順序不同，第二句就不會匹配成功， 因為在這裡雖然也包含abc三個字母, 但a和b被一個空白字元分開了 (ab c) 符號若是我們需要更複雜的搜索條件，例如：我們想要確認使用者輸入的email是否符合格式，或是搜尋一個字串中所有包含b的單字，就必須使用一些特殊符號 符號 解釋 例子 \\ 反斜線會搭配一些字母用在正規表達式的一些符號中, 但是當你想要搜尋的字剛好屬於正規表達式的特殊符號時, 可以將反斜線放在特殊符號前面, 讓它不會被視作特殊符號 a* 表示一個字串中包含0至多個a, 但a*僅代表字面意義上的a* (米字號因為反斜線而被以字面意義解釋了) a* 表示一個字串中包含0至多個a，即使沒有a這個字元也會匹配 (/a*/).test(‘bbbb’) =&gt; true a+ 表示一個字串中包含1至多個a (/a+/).test(‘bbbb’) =&gt;false ^a 匹配開頭符合a的字串 (/^a/).test(“ant”) =&gt; true a$ 匹配結尾符合a的字串 (/a$/).test(‘tesla’) =&gt;true a{num} 尋找連續出現num次的a, num為正整數, 要注意若是a出現次數大於num, 還是會算做true (/a{2}/).test(“area”) =&gt; false (/a{2}/).test(“aah”) =&gt;true (/a{2}/).test(“aaaaah”) =&gt;true a{min, max} 尋找連續出現至少min次, 至多max次的a, 跟上一條一樣的是, 要注意若是a出現次數大於max, 還是會算做true [a-z] 尋找界在a~z之間的所有字母 (/[a-z]/).test(‘abc’) =&gt;true (/[a-z]/).test(‘ABC’)=&gt; false \\ba 若斜線與b搭在一起時, 放在a前面時, 表示a前面沒有別的字元, 也就是說以a開頭, 若是放在a的後面, 表示a的後面沒有別的字元, 也就是以a結尾 (/\\ba/).test(‘bag’) =&gt; false (/\\ba/).test(‘apple’) =&gt; true (/a\\b/).test(‘apple’) =&gt; false \\d 數字, 等同[0-9] (/\\d/).test(‘123’) =&gt;true \\D 非數字 \\w 數字字母和底線 \\W 非數字字母和底線, 例如: %, *這些符號 Flags 模式 模式 解釋 /reg/g g代表global search, 表示搜索指定字串中的全部字元 /reg/i insensitive search 忽略大小寫 (/abc/i).test(‘ABC’) =&gt;true 常見用法 說明 表達式 只能輸入文字或數字 /^[a-zA-Z0-9]*$/ 只能輸入文字 /^[a-zA-Z]*$/ 只能有數字 /^[0-9]*$/","link":"/2020/03/19/regular-expression/"},{"title":"JS - sort以及演算法","text":"之前在寫網頁時需要用到sort來根據資料的日期排序，本來一切都好好的，沒想到我在檔案打包好丟到gh pages瀏覽時，居然發現在ios上sort失效了！所以開始研究了這個功能是怎麼回事…… （題外話：問題最後解決了，但好像跟sort沒有關係……） sort 會原地對一個陣列進行排序，預設是根據字串的unicode編碼位置 若是沒有帶compare function, 比較的兩個值會被轉換為字串 sort(compare function(a,b){}; 當a &lt; b 時回傳-1, a&gt;b時1, 相等時為0 演算法有分穩定/不穩定 ＊穩定排序／不穩定排序（小美，１０歲）（小明，８歲）（小王，１０歲）（強強，９歲）此時若要按照年齡由小至大排序的話，會有兩種排法1.（小明，８歲）（強強，９歲）（小美，１０歲）（小王，１０歲）2.（小明，８歲）（強強，９歲）（小王，１０歲）（小美，１０歲） 參照原本的順序，原本小美是排在小王前面的，因此在第一個排序中，小美一樣在小王前面，就可稱為是穩定排序，在第二個排序中，小王被排在小美前面，就稱為不穩定排序。 用法假設有一個陣列為[1, 3, 5, 65, 2, 4, 99] 123456789101112131415[1, 3, 5, 65, 2, 4, 99].sort(function(a,b){ if(a&gt;b) return 1; //如果A比B大, 會被排在前面 if(a&lt;b) return -1; //如果A比B小, 會被排在後面 return 0;})//或[1, 3, 5, 65, 2, 4, 99].sort(function(a,b){ return a&gt;b?1:-1; //(三元運算子)})//或[1, 3, 5, 65, 2, 4, 99].sort(function(a,b){ return a-b; }) 使用場合在chrome的v8引擎中規定，當要排序的陣列長度&lt;10時，使用插入排序（穩定），大於這個長度的陣列會用快速排序（不穩定）處理 演算法實作 4.1 氣泡排序氣泡排序的規則：（來自維基） 1. 比較相鄰的元素。如果第一個比第二個大，就交換他們兩個。 2. 對每一對相鄰元素作同樣的工作，從開始第一對到結尾的最後一對。這步做完後，最後的元素會是最大的數。 3. 針對所有的元素重複以上的步驟，除了最後一個。 4. 持續每次對越來越少的元素重複上面的步驟，直到沒有任何一對數字需要比較。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263let array = [{ name: \"aaa\", age: 100 }, { name: \"bbb\", age: 20 }, { name: \"ccc\", age: 30 }, { name: \"ddd\", age: 20 }, { name: \"eee\", age: 30 }, { name: \"fff\", age: 40 }, { name: \"ggg\", age: 20 }, { name: \"hhh\", age: 20 }, { name: \"iii\", age: 30 }, { name: \"jjj\", age: 70 }, { name: \"kkk\", age: 90 } ]; function bubble(ary) { for (var i = 0; i &lt; ary.length ; i++) { //跑迴圈 每次排完一定會有一個數字在正確位置(一定比後面的大), 所以下一輪要排的數字會固定少1 for (var j = 0; j &lt; ary.length - i - 1; j++) { //將數字倆倆比較,前面的數字比後面大時,就移到後面 if (ary[j].age &gt; ary[j + 1].age) { var temp = ary[j]; ary[j] = ary[j + 1]; ary[j + 1] = temp; console.log('後',ary[j], ary[j + 1]); } } } return ary } bubble(data); 參考資料：[偷米騎巴哥] 20180412 前端踩雷日記(解開Sort不穩定現象之謎)","link":"/2020/03/02/sort/"},{"title":"JS - 計時器與happy path","text":"計時器demo 雖然已經用Vue寫過一些小專案，但我知道自己原生JS的知識其實並不算足夠，因此趁著著手六角Vue最終作業前的一小段時間，開始上之前買的課程JavaScript Bootcamp，這堂課的後半段都是實作項目，其中有一項是製作一個簡單的計時器。原理並不複雜，在不斷驗證和調整的過程中，我想到一個詞－happy path。 起因課程中的原始碼可以看這裡 =&gt; codepen我個人的原始碼可以看這裡 =&gt; github 課程中的成品功能非常單純：使用者可以點擊中間的輸入框，輸入要設定的時間，按下開始鍵開始計時，按下暫停鍵暫停。 不過有以下幾個問題： 計時到一半按下暫停時，外圍的邊框就會重新來過，而不是從停下的地方開始。 沒有reset功能。 只能計算秒數。 本來想說只是個小作品就不管那麼多了，但想一想這些問題不解決心裡會很煩，就手賤的打開了VSCODE…..被迫捲入精神時光屋…. 什麼是Happy path (滿意路徑)？根據維基，所謂的滿意路徑就是你在設計一個功能時預設使用者會使用的方式，而不考慮任何極端或錯誤的狀況。以這個計時器來說，happy path可以是： 使用者會輸入數字 =&gt; 這些數字就會成為秒數／分鐘 =&gt; 使用者按下開始，計時器開始倒數 =&gt; 計時器在倒數時邊框會隨著遞減 =&gt; 邊框跟著時間一起歸零。 而既然有happy path，相反的就有unhappy path。 unhappy path (不滿意路徑)一個計時器能夠有什麼好unhappy的？ 以原版計時器來說，unhappy path可以有以下幾個： 使用者輸入非數字（文字／符號） =&gt; 計時器產生NaN 使用者輸入小數點 =&gt; 在運作上沒什麼問題，可是這好像太過極端 使用者在按下開始後，又誤按下開始 =&gt; 計時器的倒數莫名的加速 使用者在倒數開始後，沒有按下暫停就又直接編輯輸入框 解決結合一開始提到的缺點，並考慮到不滿意路徑，我作了一些修正。 限制使用者輸入 這是一個很直觀的解法，就是從一開始就解決使用者可能亂輸入的問題。為了解決可能的NaN問題，我使用正則表達式禁止使用者輸入數字以外的字元（包括小數點），另外，由於我的版本新增分鐘，因此也在JS中限定輸入的邊界：若使用者輸入超過60秒，會自動轉為60秒。另外，若使用者沒有輸入值，或是輸入負數，會自動轉為0，避免任何不想要的值。 其實我一開始有考慮改用select，像ios的計時器一樣，但我總覺得直接輸入有一種說不出來的魅力……？ 開始計時後，封鎖一些按鈕 計時開始後，我將開始鈕、重設鈕、時間輸入框這些我不希望使用者亂碰的區域都設為disabled，以避免任何因前述原因導致的錯誤。主動限定使用者在計時開始後只能按下暫停。 新增變數以及輸入框監測 在原版中只使用了一個變數來儲存時間，導致了計時器倒數中若按下暫停，再按下開始時邊框的錯誤。這個問題困擾我最久，最後的解法是：我使用兩個變數，一個儲存設定的時間，一個儲存剩下的時間。另外，不管有沒有按下重設，使用者編輯輸入框時，設定的時間都會重新計算。主要的目標就是：讓整個流程變得更嚴謹。 感想我認為，嚴謹的定義每個流程，是解決不滿意路徑時的中心思想，在什麼時機，使用者要做什麼，這個「什麼」是否有一個清楚的答案？有了答案，才會知道錯誤是什麼。不過，在開始動手的時候我肯定是沒有想到這麼多的，最開始時我也只是想新增一些功能而已，這些都是不斷驗證不斷校正得出的理論。 我滿喜歡這堂課的，接下來還有很多實作項目，超級期待！","link":"/2020/03/07/timer-and-happy-path/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"六角鼠年全馬挑戰賽","slug":"六角鼠年全馬挑戰賽","link":"/tags/%E5%85%AD%E8%A7%92%E9%BC%A0%E5%B9%B4%E5%85%A8%E9%A6%AC%E6%8C%91%E6%88%B0%E8%B3%BD/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"troubleshoot","slug":"troubleshoot","link":"/tags/troubleshoot/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"VeeValidate3","slug":"VeeValidate3","link":"/tags/VeeValidate3/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Leaflet","slug":"Leaflet","link":"/tags/Leaflet/"},{"name":"口罩api","slug":"口罩api","link":"/tags/%E5%8F%A3%E7%BD%A9api/"},{"name":"bootstrap","slug":"bootstrap","link":"/tags/bootstrap/"},{"name":"作品心得","slug":"作品心得","link":"/tags/%E4%BD%9C%E5%93%81%E5%BF%83%E5%BE%97/"},{"name":"正規表達式","slug":"正規表達式","link":"/tags/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E9%81%94%E5%BC%8F/"},{"name":"演算法","slug":"演算法","link":"/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"六角鼠年全馬挑戰賽","slug":"六角鼠年全馬挑戰賽","link":"/categories/%E5%85%AD%E8%A7%92%E9%BC%A0%E5%B9%B4%E5%85%A8%E9%A6%AC%E6%8C%91%E6%88%B0%E8%B3%BD/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}