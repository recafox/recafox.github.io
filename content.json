{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"從2019年的九月開始自學前端技術，在這裡紀錄一些學習的心得。最重要的是：要記得寫！！！","link":"/about/index.html"}],"posts":[{"title":"npm指令無法運作","text":"發現問題剛剛正打算繼續寫vue的專案時，要運行伺服器而在終端機使用npm run serve指令時，突然跳出沒看過的錯誤： 123npm : 無法辨識 'npm' 詞彙是否為 Cmdlet、函數、指令檔或可執行程式的名稱。請檢查名稱拼字是否正確，如果包含路徑的話，請確認路徑是否正確，然後再試一次。位於 線路:1 字元:1 接著我在cmd中也試了vue ui指令，也跳錯 1'node' 不是內部或外部命令、可執行的程式或批次檔 / 解決 'node' 不是內部或外部命令，也不是可運行的程序 到底是……！？ 解決四處搜尋了一下，似乎是環境變數跑掉了，讓電腦找不到要執行的檔案。若你也遇到類似問題，可以跟著接下來的步驟。 1.先到控制台，打開系統 2.找到進階系統設定 3.打開之後，選取環境變數 4.要處理的是下方系統變數中的Path 5.設定路徑由於這次我的npm, nodejs, git都出問題，所以把這些安裝後的路徑都填進去 或是你也可以自己輸入這些路徑，不過不同的路徑間要記得用個分號；隔開 6.按下確定後測試一下，總算解決了 ### 為什麼會發生這個問題，我四處搜尋了下，好像都沒有人知道。不過我今天在剛開電腦時跳出git更新，然後就發生這個災難了。不知道有沒有關聯呢？","link":"/2020/02/02/2020-02-02/"},{"title":"Day 1 - 反轉字串","text":"好像差不多該開始更進一步了，買了一堂叫做The Coding Interview Bootcamp: Algorithms + Data Structures的課學習演算法。我會先自己解過一次，再參考答案，這篇文章會記錄我的解法，若是我覺得其他解法有值得注意的地方，也許也會記錄在這裡。 這系列就……持續到找到工作為止吧。 題目string reversal — Directions Given a string, return a new string with the reversed order of characters — Examples reverse(‘apple’) === ‘leppa’ reverse(‘hello’) === ‘olleh’ reverse(‘Greetings!’) === ‘!sgniteerG’反轉字串。 解法我的解法1234function reverse(str) { return str.split('').reverse().join('');} 思路：將字串中每個字拆成獨自的元素，回傳成一個陣列，接著套用陣列方法將這個陣列反轉，最後將這個反轉陣列中的元素連接成一個字串。 notestring.prototype.splitarray.prototype.reversearray.prototype.join 其他解法credit to Stephen Grider 1234567function reverse(str) { let reversed = ''; for(let character of str){ reversed = character + reversed; } return reversed;} 思路：使用for of來遍歷js中可被遍歷的元素（字串、陣列）。將傳入的字串中所有的元素遍歷一遍，然後把字串中每個字加到reversed空字串中，每次累加都把原本的reversed字串加在尾巴。 參考The Coding Interview Bootcamp: Algorithms + Data Structures","link":"/2020/05/18/daily-algo-1/"},{"title":"JS - BMI計算機","text":"DEMO 目標用JavaScript做一個BMI計算機，而且可以顯示過往的測驗結果。這次一邊整理筆記一邊改寫，將當初很多段重複又累贅的地方重寫，心中很感慨，原來我也是有進步的。 預覽 難點：1.顯示結果的圓圈會根據結果數字的狀態變色2.列表的顏色也要跟著變 思考流程：1.先製作一個介面，使用者可以在相應的欄位輸入身高體重，然後按下結果按鈕 2.使用js計算使用者輸入的資料，並且將這些資料以物件的形式，儲存成一個陣列來管理。 3.這個陣列的資料同時也會儲存進local storage中，不過會是以字串的形式 4.處理完的BMI結果會呈現在欄位右方的圓圈，還有BMI狀態。 5.底下會生成一個相應的列表，記載BMI指數, BMI狀態、身高、體重、檢測日期。圓圈以及列表都會根據BMI狀態改變顏色 6.頁尾 7.結果圓圈的右下方有一個重新施測的紐，我想讓它活潑一點，所以想加一個旋轉的小動畫 8.我想要限制列表的數量，讓它不要過長。超過十五筆的話，就從最早的那一條開始刪掉。 9.我想讓列表從最新一筆紀錄開始呈現，而不是最後一筆 10.我想讓中間的列表在使用者第一次打開網頁時隱藏起來，當有紀錄時才開啟 開始動手作1.先製作一個介面，使用者可以在相應的欄位輸入身高體重，然後按下結果按鈕我將網頁分成三個部分，第一個是欄位區，叫header，中間要放檢測紀錄，就叫history，最後是頁尾，就叫footer。 先分好之後，就開始製作欄位。考慮到這個區塊的各個元素要相互對齊，我新增一個div區塊叫做cal，將這個區塊的display設定成flex，然後使用以下語法: 12align-items: center;justify-content: space-evenly; 我之前常常搞不清楚Items和content的區別，為了以防忘記．在這裡寫起來itemsalign - items和justify-items只能作用於單行 content若有多行元素時，就應使用align-content / justify-content 然後，要記得，flex這個屬性必須掛在外容器上!flexbox參考網頁 接下來，因為需要用到js抓取輸入的資料，各個輸入欄位我都下了不同的class，之後按鈕也要做變化，所以也先下了一個class。 1234567var height = document.querySelector(\".height\"); //使用者身高var weight = document.querySelector(\".weight\"); //使用者體重var resultBtn = document.querySelector(\".result-btn\"); //結果按鈕var list = document.querySelector(\".list\"); //歷史列表var his = document.querySelector(\".history\"); //要呈現列表的區塊//有了class，就可以抓取DOM元素，進行接下來JS的操作。 2.使用js計算使用者輸入的資料，並且將這些資料以物件的形式，儲存成一個陣列來管理。為了要儲存並且更好管理將來的資料，我先宣告一個陣列： 12//若是資料庫中有資料，就轉成物件存進Data, 若沒有就創造一個空陣列var data = JSON.parse(localStorage.getItem(\"BMIlist\")) || []; 這個陣列會從資料庫獲得資料，然後把資料轉化成物件儲存在自己裡面。為什麼不能直接宣告空陣列呢？因為我希望使用者在第二次第三次打開這個網頁時，都能看到自己以前的紀錄，所以要讀取資料庫的資料。這個陣列中的物件，我計劃要有以下的屬性： BMIstatus（BMI狀態）, BMIindex(BMI指數), height, weight, time, color 接下來是計算使用者資料。我寫了一個function。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function calculate(e){ //data陣列中的各個屬性處理 //1. 身高, 體重, BMI結果 var h = parseInt(height.value)/100; var w = parseInt(weight.value); var result = w/(h*h); result = result.toFixed(2); console.log(result); var status = \"\"; var color = \"\"; switch (true){ case result &lt;= 18.5: status = \"過輕\"; color = \"#31baf9\"; break; case 18.5 &lt; result &amp;&amp; result &lt;=25: status = \"理想\" color = \"#86d73f\"; break; case 25 &lt; result &amp;&amp; result &lt;=30: status = \"過重\"; color = \"#ff982d\"; break; case 30 &lt; result &amp;&amp; result &lt;=35: status = \"輕度肥胖\"; color = \"#ff6c03\"; break; case 35 &lt; result &amp;&amp; result &lt;=40: status = \"中度肥胖\"; color = '#ff6c03'; break; case 40 &lt; result: status = \"重度肥胖\" color = \"#ff1200\"; break; default: alert('資料有誤'); break; } //獲得當前日期 var date = new Date(); var day = date.getDate(); var month = date.getMonth()+1; var year = date.getFullYear(); //將計算出的資料存入一個物件中 var BMIdata = { height:h, weight:w, BMI:result, BMIstatus: status, time: month + \"-\" + day + \"-\" + year, color: color,}; //將最新的資料插入陣列中第一個，讓列表能從最新一筆開始 data.splice(0, 0, BMIdata); //將新的BMIdata(物件)存進data updateList(data); localStorage.setItem(\"BMIlist\", JSON.stringify(data)); if(data.length &gt; 15){ clear();}; switchBTN();} 一點小提醒：1.我發現如果不寫parseInt的話，height.value傳進來的會是字串而不是數字（我想是因為，.value本來就是抓取文字欄位元素的關係），為了保險起見，兩個需要傳入的變數我都加上parseInt。順帶一提，parseInt是將字串轉換為數字的一個function。 2.為了讓數字容易運算，結果看起來乾淨漂亮，我在result的數字做了toFixed(2)的處理－讓落落長的數字取到剩下小數點後兩位。 3.switch case的使用：原本我以為只能在有特定值時才可以使用，但其實換個角度想 1234if(result &lt;= 18.5){ status = \"過輕\"; color = \"#31baf9\"; } 這個意思不就代表 當result &lt;=18.5這個表達式 === true嗎？所以可以改寫為 1234switch(true){ case result &lt;= 18.5: //some action} 如此一來，物件中的BMIstatus, BMIindex, height, weight都有了，差一個time 在js中要取得當前時間，必須這樣寫： 12345//獲得當前日期 var date = new Date(); var day = date.getDate(); //取得日期 var month = date.getMonth()+1; //取得月份 var year = date.getFullYear(); //取得年分 要先呼叫一個新的Date物件，然後就可以使用下面幾個函示來取得你想要的內容。對了，getMonth()中，月份的計算是從0開始，一月（0)到十二月(11)，所以要是你想要正確的數字的話，你應該要記得加一。（那為什麼日期不也從0開始……？） 12345678var BMIdata = { height:h, weight:w, BMI:result, BMIstatus: status, time: month + \"-\" + day + \"-\" + year, color: color, }; 把物件中的各屬性配上之前寫的變數。 順帶一提，為了避免使用者沒有填入數字或是只寫零，我又加了一個function。 123456789101112resultBtn.addEventListener(\"click\", check); //按下按鈕後，先檢查是否有輸入數字，或是是否有輸入0，無前述狀況再執行計算function check(e){ if(height.value == \"\" || weight.value ==\"\"||height.value ==0 || weight.vaue == 0){ alert(\"數字不正確\"); } else{ calculate(height.value, weight.value); }};//使用者送出的資料會先跑進這個Function裡檢查有沒有零或是根本沒有填入，若是如此就會跳出一個提醒，若是都有填數字就會開始計算 3.這個陣列的資料同時也會儲存進local storage中，不過會是以字串的形式處理好陣列後，我們要來把它新增進資料庫中 1calStorage.setItem(\"BMIlist\", JSON.stringify(data)); 在資料庫中新增一個叫做BMIlist的欄位，把data陣列中的物件字串化後傳進去。這樣一來，當function calculate把資料都計算完，並且把資料儲存進陣列時，資料庫也會一起被更新。 4.底下會生成一個相應的列表，記載BMI指數, BMI狀態、身高、體重、檢測日期。圓圈以及列表都會根據BMI狀態改變顏色 我在做的時候，因為感覺旁邊的結果圓圈比較難，所以先從列表開始做。我寫了一個Function來處理這件事，這個function叫做updateList(data)，括號中間的data實際上跟上面提到的data陣列是不同的東西，之後我們還要再呼叫一次這個Function並且在括號中傳入data陣列。我只是想提醒我自己接下來要傳進去的是什麼東西。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function updateList(data){ //先抓取資料庫中資料 str = \"\"; //跑迴圈, 對每一個data中的元素都做處理 for(var i=0; i&lt; data.length; i++){ his.style.display = \"block\"; let text = ''; //使用一個template function來統一處理html function template(item){ return text =`&lt;li data-num =${i} class = listItem style = 'border-left: 7px ${data[i].color} solid'&gt;&lt;div class = 'BMIstatus'&gt;&lt;span style = 'font-size: 20px'&gt; ${data[i].BMIstatus}&lt;/span&gt;&lt;/div&gt;&lt;div class = 'result'&gt;BMI &lt;span style = 'font-size :20px; margin-left: 10px'&gt;${data[i].BMI}&lt;/span&gt;&lt;/div&gt;&lt;div class = 'weight-kg'&gt;weight&lt;span style = 'font-size :20px;margin-left: 10px'&gt;${data[i].weight}kg&lt;/span&gt;&lt;/div&gt;&lt;div class = 'height-cm'&gt;height&lt;span style = 'font-size :20px; margin-left: 10px'&gt;${data[i].height*100}cm&lt;/span&gt;&lt;/div&gt;&lt;div class = 'test-date'&gt;${data[i].time}&lt;/div&gt;&lt;/li&gt;` } //抓取陣列資料，根據抓到資料的bmistatus分類並列表 switch (data[i].BMIstatus){ case \"過輕\": template(data[i]); break; case \"理想\": template(data[i]); break; case \"過重\": template(data[i]); break; case \"輕度肥胖\": template(data[i]); break; case \"中度肥胖\": template(data[i]); break; case \"重度肥胖\": template(data[i]); break; default: alert('something is wrong!'); break; } str += text; }; list.innerHTML = str;}; 在這邊最重要的做法就是，使用innerHTML來把新增的列表元素加進ul列表中。所以我先設定一個空字串（str）的變數，在跑接下來的迴圈時，會依序加進相應的內容，最後再將這個字串變成html元素塞進ul列表中。 這樣一來，列表就完成了！這個function被放在程式碼最上面（因為我希望使用者一打開網頁時就能出現列表），還有Calculate函式中（這樣有新的資料傳進資料庫時，列表就能馬上更新）。 5. 我想要限制列表的數量，讓它不要過長。超過十五筆的話，就從最早的那一條開始刪掉。列表完成之後，在測試時發現，要是一直增加資料而沒有一個限制的話，列表就會變的落落長。要避免這件事，我決定限制陣列的長度，寫了一個function 123456789 if(data.length &gt; 15){ clear(); };function clear(){ for(var i=0; i&lt; data.length; i++){ data.splice(i, 1); }; localStorage.setItem(\"BMIlist\", JSON.stringify(data));} clear的功能是，把陣列的元素都跑一遍後，從最後那一筆刪掉一筆，然後用修剪過的陣列再更新一次資料庫。之後當陣列大於15時，就呼叫這個函式，把陣列修剪掉。看到這裡你可能覺得很奇怪，把最後那一筆刪掉的話，不就等於把最新的那筆資料刪掉嗎？這一步驟跟下一步驟環環相扣，請看： 6.我想讓列表從最新一筆紀錄開始呈現，而不是最後一筆網頁在這一步已經完成了有七成了吧。看著列表都能一一出現我已經很滿意，但是因為列表是由陣列的0~14開始跑，我想一想覺得不太對勁：最新的資料卻要滑到最下面才能看到，不是很不方便嗎？ 為了解決這個問題，我一開始的解法是使用data.reverse()反轉陣列。讓最後一筆能夠成為陣列第一筆。結果我發現，因為有許多function都在執行這個陣列，一邊反轉的話，另一邊就會出錯。 最後，我發現事情可以不用這麼複雜。 12data.splice(0, 0, BMIdata); splice( x, y, item) x是你想插入的位置，y是你想從那位置之後刪掉的資料數目，item是你想插進去的資料。使用splice，讓新的資料從第零筆插入，成為第零筆就好，最後一筆成為第一筆，原本的倒數第二成為第二筆，如此往後推進。也因此在上一步驟中的迴圈，我把最後一筆刪掉，其實也等於是把最早的刪掉。 其實我在這裡犯過不少愚蠢的錯…… 7.處理完的BMI結果會呈現在欄位右方的圓圈，還有BMI狀態。不知道為什麼，我一直很害怕這個部分，所以我拖到很後面才做。這一步中，我們要把原本的結果按鈕刪掉，然後新增一個會變色的圓圈圈，圈圈中間有BMI指數，還有一個重新開始的小按鈕，圓圈旁邊跟著一段顯示結果的文字。 先寫一個function，叫做switchBTN(){} 接著來刪掉原本的按鈕。 1234var getParent = resultBtn.parentNode;getParent.removeChild(resultBtn);var div = document.createElement(\"div\");div.setAttribute(\"class\", \"show\"); 我先取得按鈕的父元素（ParentNode），然後移除按鈕（remoceChild），接著新增一個div元素，給他一個Class名稱（我已經預先在css中設定好外觀了）。 接下來，因為這個圓圈有一些必須隨著資料變動的要素，所以就再跑一次迴圈，抓取各元素中的特定值（我要找的是bmi指數以及狀態） 接下來主要分兩部分，先寫個函式把接下來會重複的動作統一處理 1234567891011121314151617181920//這個函式其實一直在做一樣的事, 就是根據傳進來的資料, 還有這筆資料的各種屬性來渲染不同的htmlfunction btnHandle(item){ str = \"&lt;p &gt;\"+item.BMI+\"&lt;/p&gt;&lt;p style = 'font-size: 14px;'&gt;BMI&lt;/p&gt;&lt;a href = 'index.html'&gt;&lt;/a&gt;\"; div.innerHTML = str; div.style.color = item.color; div.style.border = `5px solid ${item.color}`; div.style.position = \"relative\"; var a = div.querySelector(\"a\"); a.style.backgroundColor = item.color; getParent.appendChild(div); //將str的字串新增到div元素中，設定css樣式 var p = document.createElement(\"div\"); p.setAttribute(\"class\", \"statusText\") var pStr = `&lt;p&gt; ${item.BMIstatus}&lt;/p&gt;` p.innerHTML = pStr; p.style.color = item.color; div.appendChild(p); } 然後是條件判斷 12345678910111213141516171819202122232425262728switch (data[0].BMIstatus){ case \"過輕\": btnHandle(data[0]); break; case \"理想\": btnHandle(data[0]); break; case \"過重\": btnHandle(data[0]); break; case \"輕度肥胖\": btnHandle(data[0]); break; case \"中度肥胖\": btnHandle(data[0]); break; case \"重度肥胖\": btnHandle(data[0]); break; default: alert('something is wrong!'); break; } 這個功能基本上就完成了。在這裡的做法跟做列表有點像，都使用到一個把字串塞進空字串中，然後創造html元素的做法。不過在這裡我沒有跑for迴圈，而是用switch來判斷當下的狀態，因為前面我把最新的資料都變成第零筆，所以我只要判斷第零筆的BMI狀態就好。 舉上面的例子，假如第零筆（也就是最新這一筆）的BMI狀態是過輕的話，我就在str中放進兩個p段落（一個是指數，一個是小小的bmi字樣）和一個a連結（重新開始的按鈕），這幾個元素的外觀我都在css中設定好了。 把str的HTML元素用innerHTML的方法設定好之後，接下來是根據該狀態來變更顏色。想要用js變更css樣式的話，就先把要變更的元素抓取過來，然後加上.style.color/ .border/….等等css語法。a連結也設定好之後，使用appendChild把這些新增好的元素加進剛剛的Parent node之下，就可以了。 別忘了，還有旁邊的狀態要寫！ 8.頁尾頁尾只有一個Logo要放，但是原本給的logo是透明的，不是這個顏色。我使用了css中的filter來調整，可以上codepen找css filter。 9.結果圓圈的右下方有一個重新施測的紐，我想讓它活潑一點，所以想加一個旋轉的小動畫123456789101112131415161718.show a:hover{ animation: spin 1.5s infinite; transition: ease;}/* 讓按鈕活潑 */@keyframes spin{ 0%{ 動畫的第０格時 transform: rotate(0); } 50%{ 動畫的中間 transform: rotate(360deg); } 100%{ 動畫的結尾 transform: rotate(360deg); }} 我想做的是：圖案旋轉一圈後，停止一下，再開始新的loop。除了要把iteration設定成infinite(無限)之外，因為要有間隔，所以50%和100%時做的是一樣的事，讓它停在原地。 10.我想讓中間的列表在使用者第一次打開網頁時隱藏起來，當有紀錄時才開啟到這裡網頁都完成了，但是當使用者第一次打開這個網頁時，中間的history區域因為沒有內容，會一片空白，我覺得這樣很奇怪，所以想要先把它隱藏起來，等到有資料進入時再出現。 沒想到我在這裡也花了很久！ 我一開始的做法是：把history區塊整個刪掉，先做條件判斷（當Data的長度&gt;=1時)，然後再一一新增回來。但是因為data有兩筆時也會大於一，有三筆時也會大於一，也就是說，只要有新的資料傳進來，這個條件判斷就會永遠成立，那就等於沒有用了！ 最後才靈光一閃 his.style.display = &quot;none&quot;; 我在程式馬最上面加了這一行，代表：「在網頁打開時，history列表是關起來的」，然後在updateList函式中，我才把它打開，這樣在生成列表的時候，history區塊也會跟著出現了。 心得其實距我做完這份作業已經過去幾個月了，那時候剛碰js，做得小心翼翼又戰戰兢兢的，還老是很悲觀地覺得我一定不行。能夠完成真的很開心！而且老實說，我那時的程式碼超冗長，哈哈，這次一邊整理筆記一邊改寫，將當初很多段重複又累贅的地方重寫，心中很感慨，原來我也是有進步的。算是在最近有些停滯又迷惘的日子提供一點新的動力。","link":"/2020/02/03/2020-02-03/"},{"title":"Git 指令","text":"git log 查詢過往commit紀錄(按q退出) git branch 看目前分支 還原前版git checkout 要前往的過去版號四碼git checkout master 確定還原 HEAD 目前所在位置的指標 git branch new_branch_name 新增分支 git branch 查詢目前有的分支, 目前所在分支前面會有星號 git checkout new_branch_name 切換到新增的分支 git checkout master 切回主枝 git status 目前分支的狀態, 檔案修改紀錄 git merge new_branch將新增分支中的更新也套用至master","link":"/2020/02/27/2020-02-27/"},{"title":"口罩地圖開發心得","text":"前言口罩地圖 / Rita Ho原始碼 因應這次的疫情，政府在推行實名制口罩購買後有公開藥局口罩庫存的api，在六角的社團看到後就很有興趣，也馬上打開VSCODE來練習，沒想到中間撞牆多次，耗費許多時間，是看了卡斯柏老師的直播才找到方向。 這篇文章就總結一下開發過程中印象深刻或新學習的部分。 使用技術：ajax, vue, leaflet 多資料串接如上文所說，這次的口罩api是由政府公開的，若你也有興趣的話，可以到這裡這裡，格式是json。 接資料的過程並不難，所以不多說過程，感到困難的部分是，當基本功能都開發完後，我決定使用’geolocation’ in navigators來偵測使用者位置並取得使用者附近的藥局。 使用geolocation時，我忽略了接取這個資料的過程也需要時間，我原本使用另一個函式來做資料接到後的處理，並放在vue的mounted hook，結果就是處理資料的函式先被執行，但要被處理的資料根本還沒來。 注意到這個時間差後，最後我採用的是promise這個方法。 12345678910111213141516171819202122232425//取得使用者位置let getUser = () =&gt; { return new Promise((resolve, reject) =&gt; { // return promise if (\"geolocation\" in navigator) { navigator.geolocation.getCurrentPosition(pos =&gt; { let lng = pos.coords.longitude; let lat = pos.coords.latitude; resolve([lng, lat]); this.user.userStat = true; }); } else { this.user.userStat = false; } }); }; //api資料 this.$http.get('https://raw.githubusercontent.com/kiang/pharmacies/master/json/points.json').then((res)=&gt;{ this.data = res.data.features }).then(getUser).then((data)=&gt;{ //取得使用者位置後再做下列行為 this.user.coords = data; this.flyToUser(); this.getNearby(); }); 在ajax部分，我同時使用到口罩的api和geolocation，這兩者在取得資訊速度也不相同，由於我會需要計算與使用者距離的函式，就勢必要確定兩者都取到資料後再做動作，不然會出現錯誤，但也考慮到也許使用者會不想打開位置偵測，考量之後我就用上述的順序來連接資料串接的過程，如此一來就算沒有使用者位置網站也能運行。 關於promise的部分其實我是這次遇到困難才開始研究，也只是先用求有再求好的心態，因此還不算熟悉（當時也搞到凌晨兩點了……），我想上面的程式碼可能也有我沒注意到的錯誤吧。 Leaflet 套件leaflet是一個js的地圖套件，官網，我採用的地圖是openstreetmap也有人開發出與vue適配性更高的Vue2Leaflet。 其實只使用leaflet原始的套件也是可以的，我也不太清楚兩者會有什麼差。 這次是我第一次自己研究套件和官方文檔，但是礙於我的知識有限，有時候根本是有看沒懂，甚至我一開始自己設定地圖的時候，根本不知道程式碼要放在vue的哪個位置。慘。 這次的網站只運用了leaflet最基本的一些功能，但成果我已經很滿意了，以呈現地圖和使用者交互的方面來說，真的不輸google map，另外，openstreetmap的地圖也滿精確的。真的很感謝這些開源又推廣技術的偉大團隊們。 程式碼規劃以前寫程式碼的時候，總是想說先寫再說，有就好，結果回過頭來看寫了很多重複累贅的功能或模板，這些其實都能整合起來。不知道在哪看到的話：「如果發現自己在寫第二遍一樣的東西時，就代表程式碼需要重構(refractor)了」，這次開發時謹記在心，一旦發現現在寫的東西之前好像有類似的，就會研究怎麼重構他，因此這次的成品跟之前相比真的精簡很多，每個功能我自認也都有其存在的理由。也算是有所成長了吧。 不過，永遠都不能愛上自己寫的code!! (出處不明) 在資料結構的規劃上，這次也學習到很多，經過各方觀摩後，這次也嘗試多使用物件的形式來整理資料，也能讓程式碼精簡一些，好像能比較靈活的規劃資料了。 UI規劃這次的版型是自己刻的，也有兼顧響應式，我個人很滿意在PC端的表現，雙欄式讓資料很清楚易懂，但是以現在的社會來說，以手機瀏覽的比重較重，因此在考慮手機版時，我決定讓地圖先呈現，下滑後才是結果列表。一開始的考量是結果列表比較長，文字的地址和圖像的呈現相較起來，後者似乎比較切身易懂。 不過實際使用後，總覺得一開始使用者面對一堆標示可能會搞不清楚狀況。我看到有些人是設定列表隱藏，全螢幕地圖，但問題感覺沒有解決。 另外，由於這次口罩實名制購買的規定挺繁瑣，還有關於圖示的說明，文字量有些多，因此我也不打算放在頁面上，而是需要點擊問號方塊另外打開，不知道這樣的設計夠不夠清楚呢？ 總結以我自己來說，給自己這次的表現90分了，一開始瘋狂撞牆的時候真的很痛苦，質疑自己很多次，但我都沒有放棄，四處找資料找資源，本來我以為自己可能真的不適合，但是只要我不放棄就代表我還是喜歡這件事的，我很高興這次相信了自己。","link":"/2020/02/19/2020-02-19/"},{"title":"Vue - Vee Validate 3 操作方法","text":"目標因為六角的作業需要使用到Vee validate這個套件，可是課程內使用的第二版和目前第三版已經有所差距了，爬文也找不到相關資料，所以按照官網教學自己做了一次。 使用步驟1. 安裝安裝 npm install --save vee-validate 2. import進檔案中import有兩種方法，一種是在main.js中全局import，如此一來所有元件都能使用，還有一種是在要使用的元件中局部import 2.1 全局import123456//位置:main.js (你的vue專案中的進入點)//引入import { ValidationProvider } from 'vee-validate';//啟用Vue.component('ValidationProvider', ValidationProvider); 全局引用後不用在元件中再次引用就可以直接使用了 2.2 局部引用12345678910//位置：你在使用的元件名稱.vueimport { ValidationProvider } from 'vee-validate';export default {//區域元件註冊 components: { ValidationProvider }}; 3.使用vee validate的標籤validationprovider就如同vue註冊後的元件一樣，元件的名稱就會是html標籤，validation provider就是我們要使用的標籤 123456 &lt;validation-provider rules='email' v-slot='{errors}'&gt; 包住 &lt;input type=\"text\" v-model='form.user.email'&gt; &lt;span&gt;{{errors[0]}}&lt;/span&gt; //若輸入有誤時這裡將會跳出錯誤提示 包住&lt;/validation-provider&gt; HTML無法偵測大小寫, 所以使用kebab寫法 使用validation-provider包住要驗證的input，按照需求綁定V-model，官方建議要有v-model讓套件能抓到要驗證的資料，但是你不想使用的話，也能使用prop方式 :value = value 到這時架構就完成了，不過我們還要綁定一些驗證規則(rule)，讓使用者輸入正確的資料。 4.增加驗證規則(rule)驗證規則就是你要規定這些input中必須輸入什麼樣的訊息，例如要填email的欄位就不能讓使用者填電話號碼。Vee validate其實已經內建好許多規則，但我們可以先來看看怎麼自訂規則。 （以下為全局註冊的做法，若你是在元件內註冊，你可以將這些操作換到該元件中） 4.1 引入extend12//位置:main.jsimport { extend } from 'vee-validate'; ##### 4.2 新增規則我們新增一個規則來驗證使用者是否輸入正數 (positive) 1234567891011//位置:main.js //規則名稱 //使用者輸入的值extend('positive', value =&gt; { //驗證條件: 符合的話為true，不作為 if(value &gt;= 0){ return true; };//若是使用者輸入零或是負數導致驗證條件為false, 跳出下列訊息//錯誤訊息: return '必須大於零';}); 4.3 綁定規則在剛剛的html標籤上加上rules link12345&lt;validation-provider rules='positive' v-slot='{errors}'&gt; &lt;input type=\"text\" v-model='form.user.email'&gt; 錯誤訊息 &lt;span&gt;{{errors[0]}}&lt;/span&gt;&lt;/validation-provider&gt; 註：想要套用多種規則時在這裡我們新增一個規則，規定使用者只能輸入偶數 12345678910111213extend('positive', value =&gt; { if(value &gt;= 0){ return true; }; return '必須大於零';});extend('even', value =&gt; { if(value %2 ===0){ return true; }; return '必須是偶數';}); html綁定方法只要在剛剛的positive規則旁邊，用一條直線再加上新的規則名稱就好 1234&lt;validation-provider rules='positive|even' v-slot='{errors}'&gt; &lt;input type=\"text\" v-model='form.user.email'&gt; &lt;span&gt;{{errors[0]}}&lt;/span&gt;&lt;/validation-provider&gt; 此時套用的兩個規則都會生效。 5. 引用vee validate中內建的規則－以email為例veevalidate中內建有許多規則，你可以到node_modules (套件安裝的地方) =&gt; vee validate =&gt; dist =&gt; rules中找到這裡我們以email為例 （以下仍以全域註冊的方式進行） 5.1 在main.js中引入內建的規則因為這裡只需要email，所以引入這個就好 12//位置:main.jsimport { email } from 'vee-validate/dist/rules'; 5.2 建立規則有兩種做法，分為預設訊息與自訂訊息 5.2.1 若你不需要自訂訊息的話，此時會使用預設的訊息 123// 註冊的名稱 該規則extend('email', email); 5.2.1 若你想要跳出自訂的錯誤提示 12345 //註冊的名稱extend('email', { ...email, message: '郵件地址不正確' //自訂的訊息}); 完成了！ 這篇文章使用了官方的教學文件，想要知道更深入的內容請到這邊","link":"/2020/02/12/2020-02-12/"},{"title":"Day 5 - 讀書筆記","text":"今天是讀書筆記。 資料結構當數據存在記憶體中，決定這些數據的順序和位置的，就是資料結構。 以電話簿為例，若是完全不做分類，僅是簡單的將人名和電話為一組記在紙上，就會像這樣。 人名 電話號碼 陳小美 0123456789 王小華 0123457788 陳皮皮 0987654123 林花花 0254216874 這些資料的排列並沒有特別的意義，只是按照先後順序一一加上而已。若是之後要新增，就直接加在下面。這種方法雖然新增很簡單，但是當要查詢特定資料時就很困難了。若是電話簿中有一千筆資料，某一天突然想要找到特定某人的電話時，就要由上往下找，或是由下往上、或是隨機地靠運氣找，不管哪種方法，都很費時費力。 或是我們改變資料排列的方式，改成以姓為分類來編排 人名 電話號碼 陳小美 0123456789 陳皮皮 0987654123 陳胖胖 0612751453 王小華 0123457788 王大哥 0123457788 林花花 0254216874 這樣一來，某天我們若想在一千筆資料中，找到特定的人的電話號碼，只要根據他的姓氏來尋找，就能省下很多時間。 將原始的資料按照特定的規則排列出先後順序，就是資料結構。 單向串列 (Linked list)串列(link)指的是一串由節點(node)和指標(pointer)組成的資訊串鏈，節點就是一個一個單位數據，指標是一個具有指向性的標的，指向下一個節點。藉由節點和指標，將一筆一筆資料串接成一個單向的資料鏈，串鏈末尾的指標會指向null。 節點 指標 節點 指標 節點 指標 節點 指標 節點 A → B → C → D → null 單向的串列中，若是要取用其中一筆資料，就必須從這一串資料鏈的起點開始，沿著指標一路尋找，直到找到為止，不能跳過。在這種結構中，要新增或刪除資料的話，只要改變指標指向的對象就好，但是若要尋找特定資料卻很費時。 另外，這只是最簡單的單向串列，其實還有雙向串列（節點有首尾兩個指標）、以及環狀串列（末尾的指標指向首位）等其他模式。 陣列 (Array)陣列的形式類似列表，也是將資料排成一列，但是與列表的指標不同，陣列會運用索引值來提取資料，索引，即為該筆資料在陣列中的位置。 索引 0 1 2 3 值 A B C D 由於電腦編號會從0開始，因此第一位索引值為0。要提取資料時，我們會用這樣的表示法：array[0]，就能提出第一位的A。陣列與列表方便的地方在於，我們要提取特定資料時，不用再從頭開始一個一個找，只要知道該資料在陣列中的位置，就能一步就提出來。但是陣列也有缺點，當我們想要安插一筆資料在中間時，舉例來說，我想要在B和C中間增加一個「小王」，會需要經歷以下步驟 先在陣列的末尾開闢新的位置 索引 0 1 2 3 4 值 A B C D 空位 先把C和C以後的資料都往後移一位 索引 0 1 2 3 4 值 A B 空位 C D 然後把小王給放進去 索引 0 1 2 3 4 值 A B 小王 C D 如果是串列的話，只要修改第一位和第二位節點的指標就好，但是使用陣列的話，就無法那麼簡單。 小結串列與陣列雖然很像，但是優缺點卻相反，在選擇採用哪種方式之前，要先根據狀況來評估。 參考演算法圖鑑Linked List","link":"/2020/05/23/daily-algo-5/"},{"title":"Day 3 - 反轉數字","text":"今天的題目是－反轉一串數字。我會先自己解過一次，再參考答案，這篇文章會記錄我的解法，若是我覺得其他解法有值得注意的地方，也許也會記錄在這裡。。 題目 — Directions Given an integer, return an integer that is the reverse ordering of numbers. — Examples reverseInt(15) === 51 reverseInt(981) === 189 reverseInt(500) === 5 reverseInt(-15) === -51 reverseInt(-90) === -9 反轉字串有時候題目可能會限制數字的位元數，要注意 我的解法1234function reverseInt(n) { let reversed = Math.abs(n).toString().split('').reverse().join(''); return n&lt;0? parseInt('-'+reversed):parseInt(reversed);} 思路:先將傳入的數字使用絕對值轉成正數，接著就是轉為字串、轉成陣列、反轉、拼回字串。回傳之前用三元運算子判斷，n小於零嗎？是－將反轉後的字串前面加上負號，轉為整數後回傳，不是－將反轉後的字串轉成整數後直接回傳。 noteMath.absparseIntparseInt只會轉換字串中的數字，其他被視為非數字的符號會被移除，也就是說，parseInt(-153) = -153，parseInt(153-) = 153，前者的減號被視為負號，是這個數字的一部分，後者的減號被視為減號，並不是數字的一部分。 其他解法12345function reverseInt(n) { const reversed = n.toString().split('').reverse().join(''); return parseInt(reversed) * Math.sign(n);} 思路：Math.sign若是遇到負數會回傳-1，正數回傳1，0則回傳0，運用這個特性來根據傳入的數字翻轉結果的正負屬性。其實我們不一定需要reversed這個變數，可以直接把這串程式碼丟到parseInt裡面，但是這樣會不好讀。 好的程式碼應該要很直觀、簡潔，且好讀，為了這個目的，稍微長一點也可以。 noteMath.sign 參考The Coding Interview Bootcamp: Algorithms + Data Structures","link":"/2020/05/20/daily-algo-3/"},{"title":"javascript核心篇 - 函式 partI","text":"最近在上六角學院的js核心篇，將筆記整理出來跟大家分享。 什麼是函式？函式本身是物件下的子類別，跟物件有區別。函式可以被呼叫，裡面包含程式碼的片段而不是屬性和值 1234567891011121314//函式結構function afunction(param){ var localVariable = '區域變數' console.log(this, localVariable) return '收到了' + param; //將接收的參數回傳出去}//表達式 data會接收到來自afunction的returnvar data = afunction('外部參數');console.log(data);//函式的結果: this為window(全域) localVariable為'區域變數'(不變) 回傳:收到了外部參數 當使用function這個詞來宣告函式時，該程式碼就會成為函式，這個函式可以被呼叫，裡面包含程式碼片段，也會有名稱（但不一定，若沒有名稱的話就是匿名函式） 函式陳述式 &amp; 表達式陳述式 12345678//有名稱function functionA(){ //some code... console.log('陳述式') console.log(functionA)}//呼叫functionA(); 函式有名稱(f functionA) 表達式在這裡，關鍵詞function後面沒有接名稱，被稱為匿名函式注意：不是所有表達式宣告的函式都是匿名函式 123456789//有名稱var functionB = function(){ //some code... console.log('表達式') console.log(functionB)}//呼叫functionB();//anotherFunction是一個變數，它接收的是後面所接函式的參考路徑 函式沒有名稱(f(){}) 12345678910var functionC = function functionD(){ //some code... console.log(functionC, functionD) //具名函式能夠在函式內被調用}functionC()var d = function(){ return 'cde';} 執行結果：兩者呈現的函式名稱都是functionD 立即函式 IIFEIIFE: Immediately Invoked Function Expression立即呼叫的函式表達式也被稱為會自我呼叫的匿名函式 以小括號包住一個函式的陳述式，宣告完就會立即執行，無法在函式外被再次執行 12345678910111213141516//具名(function IIFE(){ console.log('do something')}());IIFE(); //IIFE is not defined//匿名(function (){ console.log('do something')}());//後方的小括號也可以被移到外面(function (){ console.log('do something')})(); 立即函式的用法 因為 123456(function(){ var ming = '小明' console.log(ming)})()console.log(ming) //ming is not defined 使用外部變數儲存 1234567var position = (function(where){ console.log(where) return where; //回傳})('小明在這')console.log(position) //小明在這//小明在這 12345678910111213141516171819202122232425var a = {};(function(b){ b.person = '小花'})(a);//立即函式的寫法不同於一般函式，若是沒有在結尾加上分號，就會無法被編譯(function(c){ console.log(c.person)})(a)console.log(a) //a {person:'小花'}//a b c皆為同一物件//將全域(window物件)傳入函式, 新增一個全域屬性為person(function(global){ global.person = '小花'})(window);(function(c){ console.log(person)})()console.log(person) //小花 *為什麼使用IIFE可以避免汙染全域變數?IIFE在執行完後就會消失，在其內部所定義的變數也都會消失，就不會汙染到外部的變數 參考","link":"/2020/05/10/function-pt1/"},{"title":"Day 4 - 出現最多的字母","text":"今天的題目是，找出在一串字母中重複最多的那個字母。我會先自己解過一次，再參考答案，這篇文章會記錄我的解法，若是我覺得其他解法有值得注意的地方，也許也會記錄在這裡。 題目 — Directions Given a string, return the character that is most commonly used in the string. — Examples maxChar(“abcccccccd”) === “c” maxChar(“apple 1231111”) === “1” 找出字串中重複最多次的字 我的解法無解。慘。想來想去不知道怎麼辦，只好參考解答。 其他解法1234567891011121314151617181920212223//寫法一function getMaxChar(str){ let chars = {}; for(let char of str){ if(!chars[char]){ chars[char] = 1 }else{ chars[char] ++; } } console.log(chars);}//簡化function getMaxChar(str){ let chars = {}; for(let char of str){ //若是目前chars中還沒有char值，該值會是undefined,undefined不算數字是不能作運算的, 若如此,賦值為１ chars[char] = chars[char]+1 || 1; } console.log(chars) return chars;} 思路：將字串轉成物件，鍵為該字串中不重複的字母，值為該字串中個字母重複的字數 例： abcdd a b c d 1 1 1 2 123456obj = { a: 1, b: 1, c: 1, d: 2} 宣告一個物件為chars，它會記錄所有字母和其重複的次數，接著遍歷傳入字串中的每個字，若是chars物件中已經有鍵為目前遍歷到的字母，則該鍵值+1，隨著字串每個值被遍歷到，鍵值也會不斷累加。 1234567891011121314151617function getMaxChar(str){ let chars = {}; let max = 0; let maxChar = ''; for(let char of str){ chars[char] = chars[char]+1 || 1; } //for in遍歷物件中屬性 for(let key in chars){ if(chars[key] &gt;max){ max = chars[key]; maxChar = key; } } console.log(maxChar, max); return chars;} 參考The Coding Interview Bootcamp: Algorithms + Data Structures","link":"/2020/05/22/daily-algo-4/"},{"title":"Day 2 - 檢查回文","text":"今天的題目是－檢查一個句子是不是回文。我會先自己解過一次，再參考答案，這篇文章會記錄我的解法，若是我覺得其他解法有值得注意的地方，也許也會記錄在這裡。 ### 題目 — Directions Given a string, return true if the string is a palindrome or false if it is not. Palindromes are strings that form the same word if it is reversed. Do include spaces and punctuation in determining if the string is a palindrome. — Examples: palindrome(“abba”) === true palindrome(“abcdefg”) === false 檢測是不是回文 我的解法1234567891011function palindrome(str) { let reversed = str.split('').reverse().join(''); if(reversed === str){ return true; } return;}//精簡function palindrome(str) { return str.split('').reverse().join('') === str;} 另一種解法使用陣列方法every 12345Array.prototype.every(callback)function callback(element, index, array){ //...somde code} 將所有陣列內元素套入callback，設定回傳true的條件，若是全部元素皆通過的話會回傳true 12345function palindrome(str) { return str.split('').every((char, index)=&gt;{ return char === str[str.length - index -1] })} 思路：假設要來應證以下字串是否為回文 a b c b a 0 1 2 3 4 由於回文的特性，我們可以知道，從字串的中心點出發，距離相同，方向相反的兩個字母會相同。以這個例子來說，0位會等於第4位（末尾），1位會等於第3位，可以推斷，第i位的數，它的對照點位置會是array.length-i-1運用every來檢查每一個元素，檢查該元素是否等同於其對照點的值。 noteArray.prototype.every 參考The Coding Interview Bootcamp: Algorithms + Data Structures","link":"/2020/05/19/daily-algo-2/"},{"title":"getter & setter","text":"getter 和 setter算是我比較不熟悉的物件屬性，在這邊跟大家分享一下上課筆記。希望我以後也能熟練地運用。 定義和使用12345678var wallet = { total:100}//改寫totalwallet.total = 60;console.log(wallet.total) //60 Getter是取得特定值的方法，Setter能讓我們在存值之前先做一些手續。 如何使用settersetter會設定值 123456789var wallet = { total:100, set save(price){ this.total = this.total + price/2; }}//等號右邊為要傳入setter save的參數，他並不會覆蓋掉savewallet.save = 500;console.log(wallet.total); //350 注意，要使用等號將參數傳入setter save函式 如何使用gettergetter會取得值，因此要return 12345678var wallet = { total:100, get save(){ return this.total / 2; }}console.log(wallet.save); //50 注意調用的方法為物件屬性的調用方式 1234567891011var wallet = { total:100, get save(){ return this.total / 2; }, set save(price){ this.total = this.total + price/2 }}console.log(wallet); //50 注意點在使用chrome查看時，可以看到save屬性為一個括號，點開後才會有值，事實上在點開時，setter才會執行。 12345678910111213141516var wallet = { total:100, get save(){ return this.total / 2; }, set save(price){ this.total = this.total + price/2 }}//印出getter和walletconsole.log(wallet.save, wallet); //結果: 50, wallet物件//setterwallet.save = 200; 按照程式碼由上往下運作的邏輯，wallet.save = 200(setter)發生在console.log之後，也就是說，setter應該會在印出結果之後才調整total，因此wallet.save才會印出第一個結果50，然而當我們打開wallet物件中的save屬性，卻發現它變成了100。 為什麼是100？因為我們使用wallet.save = 200時，把200傳入Setter，按照Setter內的計算方式，total的值會是200/2+100 = 200，而getter的計算方法是將total(此時等於200)除以2，因此是100。 這可以證明，當我們打開chrome內getter的括號後，getter才會開始運算，而這已經發生在wallet.save = 200這一行之後了。 另一種定義方式使用defineProperty 1234567891011121314var wallet = { total:500,};Object.defineProperty(wallet,'save',{ set:function(price){ this.total = this.total + price/2 }, get:function(){ return this.total/2; }})console.log(wallet);console.log(wallet.save); 成功加上getter和setter 但是按照這方式新增的getter，特徵竟為不可列舉？ 1console.log(Object.getOwnPropertyDescriptor(wallet,'save')) 屬性特徵變成不可刪除(configurable)也不可列舉(enumerable)因此在使用defineProperty時，記得設定這兩個特徵，以免出現不想要的結果 12345678910111213141516var wallet = { total:500,};Object.defineProperty(wallet,'save',{ configurable:true, enumerable:true, set:function(price){ this.total = this.total + price/2 }, get:function(){ return this.total/2; }})console.log(wallet);console.log(Object.getOwnPropertyDescriptor(wallet,'save')) 實作上的範例12345678910111213var a = [1, 2, 3];//取得陣列最末元素//加在原型上，所有的陣列實體都能使用Object.defineProperty(Array.prototype,'last',{ get:function(){ return this[this.length-1]; }})console.log(a.last) //3var b = [3, 4, 15];console.log(b.last) //15","link":"/2020/05/02/getter-n-setter/"},{"title":"Hex post 開發心得","text":"Demo - Hex post原始碼 - github 六角舉辦的鼠年全馬挑戰賽在今年的2/3號開始了，活動內容是要每周寫一篇技術文章，為期一年，活動開始後六角釋出了官方的文章連結api，可以查看所有參加者的文章連結，這次使用了這個api做一個文章彙總網站，取名叫hex post。 構想在我打算做這份作品之前，其實已經有些人使用這份API完成過類似作品了，綜觀這些作品，大多是用列表呈現，比較著重在文章和更新順序，於是我就思考我可以做什麼跟這些作品區別開來。我開始想像如果我要做這件事，是想要什麼效果？突然我想到當我在瀏覽別人的技術部落格時，常常會是零留言、零拍手，每個人一定都很希望自己的作品有人看到、有人欣賞，因此我決定要做一份類似報章雜誌類的網站，並且希望這個網站能夠為大家提供更好的曝光。 既然決定了網站的方向，心裡也有了大概的輪廓，我參考了一些新聞網站、還有Medium的布局，畫了一些示意圖。 預期的功能有： 首頁有廣告最新文章的欄位 首頁有廣告最新更新作者的欄位 首頁也可以查看之前收藏的文章 可以收藏文章/作者 可以搜尋文章/作者 能查看收藏作者的最新文章 可以瀏覽歷史紀錄 功能規劃上以「讀」為本位，一切考量都是在思考讀者可以怎麼樣接觸更多文章，所以規劃上以讓讀者好親近好使用為主。 其實我也知道只要功能性做出來，這就是一份不錯的專案了，但我還是無法捨棄追求好看的版面 這份示意圖大概是第三份吧，原本我還打算要做的色彩繽紛一點，但是怎麼配色都覺得好俗好醜好浮誇好累喔，最後有點自暴自棄的用小畫家拉，懶得上色所以先用黑灰色示意，沒想到覺得滿好看的，顏色就這樣定下了。 可以看的出來本來我想要做的更複雜的，可以收藏文章、查看瀏覽紀錄、不管哪個頁面都有可以廣告文章的版面，想要讓文章隨時都能出現在使用者面前。 實作本次使用Vue，因為想做的更複雜，也使用了Vue Route來做多頁面，跟原生的JS相比，Vue真的讓資料結構與變化更好操作。（如果是原生JS我真的完全不知道怎麼做….要反省) 我認為這次最難的部分大概是資料間的交互以及同步吧，因為我有使用到local storage來儲存收藏清單，另外，資料的加載是每個頁面打開時才動作，因此每次打開都要重新跟local storage同步一次，而每個頁面的資料結構可能不太一樣（例如：文章頁面和首頁的收藏功能取得的資料可能不太一樣），我承認我在一開始沒有好好規劃這部分，也讓作業在一些不該變得複雜的地方複雜了起來，花很多時間在統一格式以及檢查。 說一個有點好笑的事情：其實整個作品裡我最喜歡的是文章頁的那兩個頁籤，那個圓弧、那個顏色填滿的感覺、搭配有點圓圓的文字、怎麼那麼可愛…… 另外，也調整很多初步layout上的東西，在文章頁面和作者頁面少了廣告欄位，因為實際使用上覺得會太過拖沓。重新思考很多版面的編排，還有怎麼增加使用上的便利性。像是搜索這個功能，一開始只想說簡單用個string.includes就好，後來覺得應該再加上排除大小寫，有很多這樣子的時刻：好不容易刻出來一個功能，但怎麼看都不滿意，這邊應該要如何如何，那邊應該要這樣這樣…… 可改進的地方網站上線之後有貼到六角的社群，得到一些寶貴的意見，大部分是版面的安排和css的小動畫，可以得到別人的回饋真的是很棒的事，而且大家還仔細的看了我的原始碼給出建議，真的很感謝。 這次也是我第一次使用scss，不過我課程才上到一半，很多觀念都還不會，因此寫得亂七八糟（笑）。 也有請六角的助教替我code review，沒有被發現什麼可怕的錯誤，只是一些排版上的小建議，我本來超擔心的哈哈哈哈哈哈哈哈。但我其實還沒有修…… 還有一點比較遺憾，是沒有做出收藏作者的功能，我本來滿期待做這個的，但是製作這個專案的時間超乎我預期，覺得自己應該再往前進了，就先擱下不做，也許在鐵人賽進行的這一年我會把它完成。 另外，在ios上瀏覽的體驗有些不如我預期，因為我沒有清除掉ios上的樣式，導致按鈕和選單出現錯位，但我嘗試了查到的一些方法都沒有效果，六角的助教也說沒有發現這問題，謎。 感想這樣寫下來，好像沒有寫到什麼很技術的東西（笑），即使經過這次專案，好像也不能說對vue更熟了些（？），有很多很多需要再改進的地方，也有很多想嘗試的功能最後沒用到（像是謎之slot），不過也學到很多小技巧，更有收穫的是在製作過程中的思考，不是只把這個網站當作一個作業，而是一個產品，它有符合我的想像嗎？有符合我的初衷嗎？另外，想像使用者會怎麼使用它，也許會遇到什麼問題，也許會欣賞其中的那些細節，就會讓人想花更多時間打磨，這是一個很有趣的過程，剛好在要準備Vue最終作業之前，給自己打氣一下。 期望每個人在創作時都有人欣賞，閱讀時都有所收穫！","link":"/2020/03/10/hex-post/"},{"title":"運用JS中的函式方法做一些小挑戰！","text":"雖然學習JS也一段時間了，但有時寫起來就是會卡卡不順，所以在udemy上買了一堂The Modern Javascript Bootcamp Course，這份課程看起來兼具觀念與實作，看起來很符合我的需要。 講師在其中一堂講函式的課中提供了一些小挑戰，都是運用陣列的常見方法來解，那就來做做看吧！ 小挑戰01: isValidPassword函式寫一個isValidPassword函式, 參數為password和usernamepassword必須符合 不得包含username 不得包含空白 不得小於8個字元 若有以上情形, 則回傳false若都沒有, 則回傳true 12345678910111213141516function isValidPassword(password, username){ let passStr = password.toString(); let userStr = username.toString(); //表達式: 會回傳值(true/false) const tooShort = passStr.length &lt;8; //使用string.includes()檢查, 會回傳true/false const hasSpace = passStr.includes(' '); const hasUser = passStr.includes(userStr); console.log('tooShort?'+tooShort, 'Space?' + hasSpace, 'User?' + hasUser); //若是以下任一值為true, 則回傳false(沒有通過密碼條件) if(tooShort || hasSpace ||hasUser){ return false; } return true; } 檢查字串中是否包含某字串 –字串方法: indexOf &amp; includesa. string.indexOf() –會回傳數值 1234'HELLO WORLD'.indexOf('E'); *// 1 在第一個位置發現E*'EEEEE'.indexOf('E'); //0 會回傳第一個找到該數值的位置'Hello there!'.indexOf(' '); //5 也可查找空白值 b.string.includes() – //回傳布林 true/false 12'Hello World'.includes('H') //true'Hello there!'.includes(' ');//true 也可查找空白值 小挑戰02: 平均數函式用一個函式來計算參數們的平均數，傳入的數字不限 1234567891011//因為不知道會傳入多少數字, 所以使用...arg, 此時傳入的所有參數都將成為一個陣列function findAverage(...arg){ let nums = arg; //用reduce累加 let sum = nums.reduce((a,b)=&gt;a+b); let length = nums.length; let result = sum/length; console.log(arg); return result; } array.reduce() – 累加的好工具還沒搞清楚[0, 1, 2, 3, 4].reduce( function ( accumulator累加器, currentValue目前數字(由左至右遍歷), currentIndex(可省)目前數值的索引值, array(可省)陣列 ) { return accumulator + currentValue; }, initialValue初始值); (mdn的表格) 使用reduce時會有兩種狀況: 狀況一：若沒有特別定義初始值, 此時陣列的第一個數會成為第一個accumulator, 第一個數和第二個數相加後的值為第二個accumulator, 與第三個數相加, 此時得出的值又成為下一個accumulator, 直到最後一個數字加完為止。 狀況二：有定義Initial value 1[1,2,3].reduce((a,b)=&gt;a+b累加函式, 10初始值) //16 此時初始值(10)會成為第一個accumulator, 第一個數和第二個數相加後的值為第二個accumulator, 與第三個數相加, 此時得出的值又成為下一個accumulator, 直到最後一個數字加完為止。 小挑戰03: 全字母句子(pangram)輸入一個句子作為參數, 檢測這個句子中是否包含英文的全部字母。每個字母必須使用至少一次。 一開始想說使用set來篩選不重複元素，set的特性就是不會收錄重複的元素 123456789101112131415//作法一function isPangram(string){//把所有字母轉成小寫，再將字串每個字分割並形成一個陣列，不包含空白let str = string.toString().toLowerCase().split('');for(let i=0; i&lt;str.length; i++){ if(str[i]===' '){ str.splice(i,1); }}let set = new Set();//這個字母沒出現在set中嗎？true(沒有),收入set：false(已出現)回傳false並跳出let result = str.filter(item =&gt; !set.has(item)? set.add(item):false)//英文字母有26個，若是每個都不重複地被收錄到的話，set的長度應該為26return set.size === 26;} 這時發現一個致命缺點：英文以外的文字也會被算進去!!!!! 12345678910111213function isPangram(string){ const alphabet = 'abcdefghijklmnopqrstuvwxyz'; let str = string.toString().toLowerCase(); let included = []; //遍歷陣列中所有元素 for(letter of alphabet){ if(str.includes(letter)){ included.push(letter); } }; return included.length === 26;} //正宗解法..... 小挑戰04: 抽牌用一個函式來隨機產生一張牌, 牌上有值(‘1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’,’10’,’J’,’Q’,’K’,’A’，和花色’clubs’, ‘hearts’,’diamond’, ‘spade’，最後回傳物件 {value:1, suits:’clubs’} 1234567891011121314//因為花色和數字都要抽隨機, 所以用另一支函式管理//回傳該陣列中的索引值function getRandom(arr){ //記得不要+1, 不然永遠抽不到第一個! let num = Math.floor(Math.random()*arr.length); return arr[num]}function getCard(){ let values = ['1','2','3','4','5','6','7','8','9','10','J','Q','K','A']; let suits = ['clubs', 'hearts','diamond', 'spade']; return {values: getRandom(values),suits: getRandom(suits)}} 心得本來想說使用js也一段時間了，這份課程又是面向初心者開的，我一定能輕輕鬆鬆解決，沒想到每個小挑戰也花了我不少時間，有時就只差一個我不知道的陣列方法或字串方法就能解題，看來我對js的熟悉程度還是得加強才行！要是你對這些小挑戰有興趣，也可以自己試試看喔！ :)","link":"/2020/04/22/js-function-methods/"},{"title":"javascript核心篇 - 物件 partI","text":"最近在上六角學院的js核心篇，將筆記整理出來跟大家分享。 物件的宣告(推薦)物件實字 Object Literals 123456789101112131415161718192021//value可以是純值, 原始型別, 函式或另一個物件//屬性名稱一定要是字串, 應避免 0:1 var family = { property: value, name:'貓貓家', deposit: 500, members:{ big_cat:'大貓貓', small_cat:'小貓貓' }, food:['fish', 'dryFood'], callFamily: function(){ console.log(this) //這個family物件 }, callAgain: ()=&gt;{ console.log(this) //window物件 } } 物件建構式 12var newFamily = new Object(family)newFamily == family //true 物件的取值、新增和刪除 取值 family.membersfamily[‘members’]使用中括號不只可使用字串方式取值，可以用數字，也可以使用變數方式作取值，甚至在中括號中做運算後再取值 123family['food'][0] //'fish'let a = 0;family.food[a] //'fish' 新增 1234//新增一個屬性叫pet, 值為hamster family.pet='hamster'//新增一個屬性叫mouse, 值為jerry family[\"mouse\"] = 'jerry' 刪除 delete 123456789delete family.fooddelete family['food']//結果name: \"貓貓家\"deposit: 500members: {big_cat: \"大貓貓\", small_cat: \"小貓貓\"}callFamily: ƒ ()callAgain: ƒ () 變數與物件屬性的差異變數無法被刪除，物件的屬性才可以 1234567891011//此時a,b都存在在window物件下//a為變數var a = 1;//b是window物件內的propertyb=2;delete a; //falsedelete b; //true 可被刪除console.log(a) //1 無法被刪除console.log(b) //not defined (被刪除了)","link":"/2020/04/07/js-object-part1/"},{"title":"陣列常用方法","text":"這是我的陣列方法筆記。不一定詳盡，就給自己做個紀錄。（詞窮） forEach12345678910111213141516171819202122232425262728const people = [ { name: '小明', money: 500 }, { name: '漂亮阿姨', money: 3000 }, { name: '杰倫', money: 60000 }, { name: '老媽', money: Infinity }];// forEach 與 map// 將所有物件增加 icash 有多少金額的欄位// for(let i=0; i&lt; people.length; i++){// console.log(people[i]);// }//通常不會用到people.forEach(function(item, index, array){ console.log(item, index, array);}) map跟forEach很像,但會回傳值 123456789101112//要有一個變數來儲存MAP回傳的值let peopleCash = people.map(function(item, index, array){ //回傳一個物件 //物件中包含該陣列的每一個元素, 在每個元素上再新增一屬性為icash return{ ...item, iCash: item.money +500 } })console.log(peopleCash); 若是沒有使用return, 還是會回傳一個跟原本長度相同的陣列, 但內容會是undefined用map做篩選： 123456789101112131415//若是使用map做篩選const peopleCash = people.map(function(item, index, array){ //篩出金額大於2000的元素 if(item.money &gt;2000){ return item; } })console.log(peopleCash);//outcome 0: undefined1: {name: \"漂亮阿姨\", money: 3000}2: {name: \"杰倫\", money: 60000}3: {name: \"老媽\", money: Infinity} 沒有通過篩選條件的還是會回傳, 值會是undefined, 所以不適合 filter會將通過條件的才回傳filter和map都要傳入一個函式, 參數為item(各元素), index(索引值), array(要傳入的陣列) 12345678const filteredPeople = people.filter(function(item, index, array){ //會回傳值為true的元素, 是一個陣列 // return true; if(item.money &gt;2000){ return true; }});console.log(filteredPeople); find找到的資料只會回傳第一個符合條件的, 會按照原本的格式回傳 1234567891011// find// 1. 找到金額 = 500 的物件// 2. 找到 &gt; 5000 的物件const findPeople = people.find(function(item, index, array){ //找到的資料只會回傳第一個符合條件的, 會按照原本的格式回傳 if(item.money &gt;2000){ return true; }});console.log(findPeople); //{name: \"漂亮阿姨\", money: 3000} every設定一個檢查條件若是全部元素都通過, 就回傳true, 反之就false 123456const ans = people.every(function(item, i){ //設定一個檢查條件 //若是全部元素都通過, 就回傳true, 反之就false return item.money &gt; 50;});console.log(ans); //每個元素都有超過50, true (布林) some設定一個檢查條件若是有其中一個元素都通過, 就回傳true, 反之就false 123456789// some// 1. 是否有物件超過 10000 元// 2. 是否有物件持有金額少於 300元const some = people.some(function(item, i){ //設定一個檢查條件 //若是有其中一個元素都通過, 就回傳true, 反之就false return item.money &gt; 50000;});console.log(some); //有其中幾個超過50000, true (布林) reduce設定一個檢查條件若是有其中一個元素都通過, 就回傳true, 反之就false 123456789101112131415161718192021// reduce// 去除掉老媽，請問剩下的人有多少錢？// 會回傳,適合用於數字運算 //前一個(沒有前一個就逗號後補零)// const newNum = people.reduce(function(prev, item, index ){// console.log(prev); //0// return prev +500; //500 1000 1500// }, 0) //0會被帶入prev// const newNum = people.reduce(function(prev, item, index ){// console.log(prev); //0// return prev +500; //600 1100 1600// }, 100)//加總const newNum = people.reduce(function(prev, item, index){ console.log(prev); //0 return prev + item.money; //0 500 3500 63500 (最後一個數字為加總)}, 0);console.log('newNum' + newNum); //63500 沒了","link":"/2020/04/02/js-array/"},{"title":"javascript核心篇 - 物件 partII","text":"最近在上六角學院的js核心篇，將筆記整理出來跟大家分享。 物件與純值在javascript中只有兩種型別：純值和物件。純值(字串, 數字和布林)無法新增屬性，但物件可以。陣列和函式也是物件 1234567891011121314151617181920212223242526272829303132333435363738var string = 'a string'//建構式var newString = new String('a new string')console.log(string) //'a string'console.log(newString) /*String {\"a new string\"}0: \"a\"1: \" \"2: \"n\"3: \"e\"4: \"w\"5: \" \"6: \"s\"7: \"t\"8: \"r\"9: \"i\"10: \"n\"11: \"g\"*/newString.name = 'a name'console.log(newString)/*String {\"a new string\", name: \"a name\"}0: \"a\"1: \" \"2: \"n\"3: \"e\"4: \"w\"5: \" \"6: \"s\"7: \"t\"8: \"r\"9: \"i\"10: \"n\"11: \"g\"name: \"a name\" * */ newString是使用建構式產生的，此時它就不是純值（字串），而是物件，可以被賦予新的屬性和方法 *陣列也是物件，陣列是物件底下的一種子型別 未定義的物件屬性預設值若是查找物件下沒有定義過的屬性，會得到undefined的結果，在undefined上無法新增任何屬性。 123456var family = { name:'貓貓家'}console.log(family.dad) //undefined 物件的參考特性傳值 vs 傳參考 傳值person和person2是兩個完全不同的變數，person2只是得到跟person的複製品，其本身與person已無關 123456var person = '小花'var person2 = person;person2 = '花花'console.log(person, person2) //小花 花花console.log(person === person2) //false 傳參考person和person2這兩個物件共享同一個參考位置，參考位置上的屬性變，共享這個位置的物件的相應屬性也會改變 123456789var person = { name:'小花'}var person2 = person;person2.name='花花'console.log(person, person2) // {name:花花} {name:花花}console.log(person === person2) //true//這兩個物件共享同一個參考位置，參考位置上的屬性變，共享這個位置的物件的相應屬性也會改變 純值傳值（布林／數字／字串／undefined/null），物件傳參考（物件／陣列／函式） 123456789101112131415var person = { name:'小花'}var person2 = person;//此時person和person2共享參考位置, 兩者嚴格相等//這時person2被重新宣告，指向另一個參考路徑//此時person和person2已不相等person2.name={ name:'小花' }console.log(person, person2) // {name:小花} {name:小花}console.log(person === person2) //false//這兩個物件共享同一個參考位置，參考位置上的屬性變，共享這個位置的物件的相應屬性也會改變 一些觀念練習題： 1234567var x = {x:1}x.y = x;console.log(x)/* 不斷指向自己本身 * x: 1 ,y: {x: 1, y: {x:1, y:{x:1, .....}*/ 123456789101112131415var a = {x:1}var b = a//此時a === ba.y = a = {x:2}//同時執行兩件事：a.y = {x:2} a = {x:2}//此時a = {x:2} 參考位置已不同 a = {x:2}這個新位置//而a.y這時的參考位置還沒有變，此時的a.y === b.y，b.y被賦予{x:2}這個位置//這時a!==b，在a中並沒有y這個屬性console.log(a.y) //undefinedconsole.log(b) //b = {x:1, y:{x:2}}console.log(a === b.y) //true 1234567891011121314151617181920212223242526變數 值 參考位置var a = {x:1} (0x01)var b = a; (0x01)a.x = {x:2} (0x02)a.y = a = {y:1}//同時執行這兩件事//a = {y:1} (0x03) a被重新指派//a.y (0x01) = {y:1} (0x03) === b.y(0x01) = {y:1}console.log(a) // a(0x03) = {y:1}console.log(b) //b(0x01) = {x: {x:2}, y:{y:1}}console.log(b.y === a) //truevar a = {}; 0x01var b = a; 0x01var c = {number:1} 0x02 b = {number:1} 0x02var c = b = {number:1}; //0x02c.name = '小明'console.log(a) //{}console.log(b) //{number: 1, name: \"小明\"}console.log(c) //{number: 1, name: \"小明\"} Call by Sharing ?Call by Sharing以javascript來說，當有多個變數被賦予同個物件時，他們就共享一個參考位置，這就是call by sharing，此時若其中一個物件中的屬性被變動，參考位置上的原始物件內的屬性也會變動，連帶造成其他的物件也都產生相同變化。 淺層 / 深層複製淺層複製 shallow copy使用for in 12345678910111213141516171819var family = { name:'貓貓家', members:{ father:'爸爸貓', mother: '媽媽貓', son:'喵喵貓' }}var newFamily = {};//列出family物件中的所有屬性for(var key in family){ console.log(key); //name members //讓newFamily擁有family中一樣的屬性 newFamily[key] = family[key];}newFamily.name = '狗狗家'console.log(family, newFamily) //{name:貓貓家...} {name:狗狗家...}console.log(family === newFamily) //false//這兩個物件是完全不同的物件，不共享相同的參考位置 要注意的是，這種方法只能複製最外層的物件，也就是family物件，但是內層的members，即使在for迴圈中被複製過去，newFamily和family中的members還是一樣的（因為沒有為它開闢新的記憶體空間） 使用jquery 1var newFamily2 = jQuery.extend({}, family) ES6 1var newFamily2 = Object.assign({}, family) 深層複製 將原物件轉為字串後，讓它失去物件的特性，再parse回來。這樣一來新物件和舊物件會成為完全獨立的物件，裡面的屬性即使包含多少層物件，參考位置也已經完全不同。 123456789101112console.log(JSON.stringify(family))//\"\"{\"name\":\"貓貓家\",\"members\":{\"father\":\"爸爸貓\",\"mother\":\"媽媽貓\",\"son\":\"喵喵貓\"}}\"\"let newFamily = JSON.parse(JSON.stringify(family))console.log(newFamily === family) //false//此時newFamily跟family已經沒有任何關聯newFamily.members.father = '爸爸狗'console.log(newFamily)/*name: \"貓貓家\"members: {father: \"爸爸狗\", mother: \"媽媽貓\", son: \"喵喵貓\"}__proto__: Object*/ 陣列陣列雖然在js中被視為物件，但是取值方式只有使用中括號一種，只能用push方法新增 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//literallet newArray = [1, 2, 'string', true, { name:'小明'}]console.log(newArray)/*0: 11: 22: \"string\"3: true4: {name: \"小明\"}*///取值newArray[0] //1//新增newArray.push('new value')//增加屬性newArray.name = '小花'/*0: 11: 22: \"string\"3: true4: {name: \"小明\"}5: \"new value\"name: \"小花\"*///注意: 此時小花是屬性，而不是陣列內的元素//目前陣列長度為5, 若是直接新增一個為在第10位的值會如何?newArray[10] = '我是第十位'newArray.forEach((item, index) =&gt;{console.log(`第${index}位`, item)})console.log(newArray.length) //11/* 第0位 1 第1位 2 第2位 string 第3位 true 第4位 {name: \"小明\"} 第5位 new value 第10位 我是第十位*///第6~9會是空值，屬於他們的記憶體位置有存在，但是沒有值console.log(newArray[6]) //undefined JSONJSON跟物件的不同之處 - 它是獨立於程式語言之外的文字。JSON是字串，且屬性名稱一定用雙引號撰寫 12345678910let example = { property: 'value',}//將物件轉為json格式let jsonExample = JSON.stringify(example)//{\"property\":\"value\"}//將JSON轉為JSJSON.parse(jsonExample)","link":"/2020/04/14/js-object-part2/"},{"title":"JavaScript中的括號問題","text":"之前在上一堂線上課程時，發現js在執行函式時有無括號的不同，有一位同學給出的解答我覺得很有幫助，翻譯出來給大家參考。 這篇文章譯自課程The Modern JavaScript Bootcamp中的一篇問答。這堂課雖然號稱開給初心者，但後半都是實作項目，雖然很有趣，但會碰到一些較進階的問題，且老師不一定有時間解答，而且有時候老師回答的超級簡短，若是沒辦法搞清楚，可能會懵懵懂懂不知道自己在幹嘛。 前情提要這份實作是要做出一個使用者在填寫搜尋欄位時，欄位會綁定監聽器，將輸入值與API的資料匹配．自動跳出符合結果的Autocomplete小工具，其中為了讓Ajax請求送出的頻率不要太過頻繁，原課程中使用了一個名為debounce的函式，這個函式中包含一個負責根據欄位輸入來送出請求的閉包。接著在input欄位綁定監聽，執行debounce。但是為什麼事件發生時執行的不是debounce而是裡面的閉包？造成很多人的疑問。 以下原文搭配中文譯文，因為提及該課堂作業的一些程式碼，為了讓讀者好理解，做過一些刪減 正文When you initially load up your JS code, the code gets evaluated by the JS Engine.在程式碼執行之前，會被js的引擎評估 To a JS parser, the two lines are different: each producing unique outcome對js的編譯器來說，以下這兩行是不同的，產生的結果也完全不同 inputValue.addEventListener(&quot;input&quot;, debounce(onInput, 500)); inputValue.addEventListener(&quot;input&quot;, debounce); The first line tells the ENGINE to invoke the debounce function immediately and replace it with its result.第一行告訴引擎直接執行這個函式，並且將它替換成它的結果 the anonymous closure is the result it produces, which ,as Stephen states above, gets repeatedly executed, each time a user types something into the input field結果就是它內部所含的匿名閉包，正如stephen（講者）所說，這個閉包會在使用者輸入欄位時被重複執行 The second line just references a function name that shall be executed when the input event is triggered.第二行則是說當input事件發生時在執行這個函式 Here’s a little demo :這裡是一點小示範 Imagine you have two, typical function declarations that you wish to assign to a particular object : ROBOT in our example :想像你有兩個宣告方式一樣的函式，你想將這兩個函式分派給一個物件：robot 1234567891011121314151617181920212223242526272829303132//宣告 function identity(){ return this } //宣告 function whoAmI(){ return ` Who am I ? ${name} `} //物件 let robot= { name: \" I am a Robot\", identity:identity, //沒有括號 whoAmI:whoAmI() //有括號 } console.log(robot.identity());console.log(robot.whoAmI()); Pay close attention how the two functions are being assigned/ referenced inside of the robot object.請注意看看這兩個在robot物件中是怎麼被指派的。 when the robot has its methods invoked , one of those methods - robot.whoAmI() - produces an error.當robot使用這兩個函式時，其中一個－robot.whoAmI()出錯了 As you can see from the image above, robot.whoAmI no longer points to the function .如你所見，此時robot.whoAmI不再指向一個函式 And that is correct with accordance to this line :但是根據這行程式碼, 這其實是正確的結果 whoAmI:whoAmI() The line tells the ENGINE to invoke the whoAmI function immediately and replace it with its result.這一行程式碼告訴引擎馬上執行這個函式, 並且用它產生的結果替換它 而whoami產生的結果就是回傳一個字串，而字串並不是一個函式，所以也無法被呼叫。 結論：inputValue.addEventListener(&quot;input&quot;, debounce(onInput, 500));而在原文的程式碼中，debounce函式在addEventListener被掛上時，其實就執行過了，它會被替換成裡面的閉包函式，這個函式才是監聽器被觸發時真正被呼叫的，也會接收到event。 也就是說，js的編譯器在遇到括號時就會馬上執行，這也是立即執行函式(IIFE)的基礎。","link":"/2020/03/26/js-parentheses/"},{"title":"正規表達式 - 符號&常用方法","text":"最近發現自己還滿常用到正規表達式的，每次都是上網找然後複製貼上，因為看起來像亂碼一樣每次看都覺得頭痛，今天就參考MDN來學習一下，放在這裡讓自己以後都可以查。 寫法const regExp = / regExp /用兩個斜線包住 或是使用正規表達式的建構函式 const regExp = new RegExp(&quot;regexp&quot;) 簡易模式找到的直接匹配所構成的，也就是結果會完全匹配要搜尋的字串 例：尋找abc“Let’s sing abc song!” “grab crab” 要尋找”abc”時，第一個句子會匹配成功，因為在這個句子中有abc，沒有斷開也沒有順序不同，第二句就不會匹配成功， 因為在這裡雖然也包含abc三個字母, 但a和b被一個空白字元分開了 (ab c) 符號若是我們需要更複雜的搜索條件，例如：我們想要確認使用者輸入的email是否符合格式，或是搜尋一個字串中所有包含b的單字，就必須使用一些特殊符號 符號 解釋 例子 \\ 反斜線會搭配一些字母用在正規表達式的一些符號中, 但是當你想要搜尋的字剛好屬於正規表達式的特殊符號時, 可以將反斜線放在特殊符號前面, 讓它不會被視作特殊符號 a* 表示一個字串中包含0至多個a, 但a*僅代表字面意義上的a* (米字號因為反斜線而被以字面意義解釋了) a* 表示一個字串中包含0至多個a，即使沒有a這個字元也會匹配 (/a*/).test(‘bbbb’) =&gt; true a+ 表示一個字串中包含1至多個a (/a+/).test(‘bbbb’) =&gt;false ^a 匹配開頭符合a的字串 (/^a/).test(“ant”) =&gt; true a$ 匹配結尾符合a的字串 (/a$/).test(‘tesla’) =&gt;true a{num} 尋找連續出現num次的a, num為正整數, 要注意若是a出現次數大於num, 還是會算做true (/a{2}/).test(“area”) =&gt; false (/a{2}/).test(“aah”) =&gt;true (/a{2}/).test(“aaaaah”) =&gt;true a{min, max} 尋找連續出現至少min次, 至多max次的a, 跟上一條一樣的是, 要注意若是a出現次數大於max, 還是會算做true [a-z] 尋找界在a~z之間的所有字母 (/[a-z]/).test(‘abc’) =&gt;true (/[a-z]/).test(‘ABC’)=&gt; false \\ba 若斜線與b搭在一起時, 放在a前面時, 表示a前面沒有別的字元, 也就是說以a開頭, 若是放在a的後面, 表示a的後面沒有別的字元, 也就是以a結尾 (/\\ba/).test(‘bag’) =&gt; false (/\\ba/).test(‘apple’) =&gt; true (/a\\b/).test(‘apple’) =&gt; false \\d 數字, 等同[0-9] (/\\d/).test(‘123’) =&gt;true \\D 非數字 \\w 數字字母和底線 \\W 非數字字母和底線, 例如: %, *這些符號 Flags 模式 模式 解釋 /reg/g g代表global search, 表示搜索指定字串中的全部字元 /reg/i insensitive search 忽略大小寫 (/abc/i).test(‘ABC’) =&gt;true 常見用法 說明 表達式 只能輸入文字或數字 /^[a-zA-Z0-9]*$/ 只能輸入文字 /^[a-zA-Z]*$/ 只能有數字 /^[0-9]*$/","link":"/2020/03/19/regular-expression/"},{"title":"JS - sort以及演算法","text":"之前在寫網頁時需要用到sort來根據資料的日期排序，本來一切都好好的，沒想到我在檔案打包好丟到gh pages瀏覽時，居然發現在ios上sort失效了！所以開始研究了這個功能是怎麼回事…… （題外話：問題最後解決了，但好像跟sort沒有關係……） sort 會原地對一個陣列進行排序，預設是根據字串的unicode編碼位置 若是沒有帶compare function, 比較的兩個值會被轉換為字串 sort(compare function(a,b){}; 當a &lt; b 時回傳-1, a&gt;b時1, 相等時為0 演算法有分穩定/不穩定 ＊穩定排序／不穩定排序（小美，１０歲）（小明，８歲）（小王，１０歲）（強強，９歲）此時若要按照年齡由小至大排序的話，會有兩種排法1.（小明，８歲）（強強，９歲）（小美，１０歲）（小王，１０歲）2.（小明，８歲）（強強，９歲）（小王，１０歲）（小美，１０歲） 參照原本的順序，原本小美是排在小王前面的，因此在第一個排序中，小美一樣在小王前面，就可稱為是穩定排序，在第二個排序中，小王被排在小美前面，就稱為不穩定排序。 用法假設有一個陣列為[1, 3, 5, 65, 2, 4, 99] 123456789101112131415[1, 3, 5, 65, 2, 4, 99].sort(function(a,b){ if(a&gt;b) return 1; //如果A比B大, 會被排在前面 if(a&lt;b) return -1; //如果A比B小, 會被排在後面 return 0;})//或[1, 3, 5, 65, 2, 4, 99].sort(function(a,b){ return a&gt;b?1:-1; //(三元運算子)})//或[1, 3, 5, 65, 2, 4, 99].sort(function(a,b){ return a-b; }) 使用場合在chrome的v8引擎中規定，當要排序的陣列長度&lt;10時，使用插入排序（穩定），大於這個長度的陣列會用快速排序（不穩定）處理 演算法實作 4.1 氣泡排序氣泡排序的規則：（來自維基） 1. 比較相鄰的元素。如果第一個比第二個大，就交換他們兩個。 2. 對每一對相鄰元素作同樣的工作，從開始第一對到結尾的最後一對。這步做完後，最後的元素會是最大的數。 3. 針對所有的元素重複以上的步驟，除了最後一個。 4. 持續每次對越來越少的元素重複上面的步驟，直到沒有任何一對數字需要比較。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263let array = [{ name: \"aaa\", age: 100 }, { name: \"bbb\", age: 20 }, { name: \"ccc\", age: 30 }, { name: \"ddd\", age: 20 }, { name: \"eee\", age: 30 }, { name: \"fff\", age: 40 }, { name: \"ggg\", age: 20 }, { name: \"hhh\", age: 20 }, { name: \"iii\", age: 30 }, { name: \"jjj\", age: 70 }, { name: \"kkk\", age: 90 } ]; function bubble(ary) { for (var i = 0; i &lt; ary.length ; i++) { //跑迴圈 每次排完一定會有一個數字在正確位置(一定比後面的大), 所以下一輪要排的數字會固定少1 for (var j = 0; j &lt; ary.length - i - 1; j++) { //將數字倆倆比較,前面的數字比後面大時,就移到後面 if (ary[j].age &gt; ary[j + 1].age) { var temp = ary[j]; ary[j] = ary[j + 1]; ary[j + 1] = temp; console.log('後',ary[j], ary[j + 1]); } } } return ary } bubble(data); 參考資料：[偷米騎巴哥] 20180412 前端踩雷日記(解開Sort不穩定現象之謎)","link":"/2020/03/02/sort/"},{"title":"JS - 計時器與happy path","text":"計時器demo 雖然已經用Vue寫過一些小專案，但我知道自己原生JS的知識其實並不算足夠，因此趁著著手六角Vue最終作業前的一小段時間，開始上之前買的課程JavaScript Bootcamp，這堂課的後半段都是實作項目，其中有一項是製作一個簡單的計時器。原理並不複雜，在不斷驗證和調整的過程中，我想到一個詞－happy path。 起因課程中的原始碼可以看這裡 =&gt; codepen我個人的原始碼可以看這裡 =&gt; github 課程中的成品功能非常單純：使用者可以點擊中間的輸入框，輸入要設定的時間，按下開始鍵開始計時，按下暫停鍵暫停。 不過有以下幾個問題： 計時到一半按下暫停時，外圍的邊框就會重新來過，而不是從停下的地方開始。 沒有reset功能。 只能計算秒數。 本來想說只是個小作品就不管那麼多了，但想一想這些問題不解決心裡會很煩，就手賤的打開了VSCODE…..被迫捲入精神時光屋…. 什麼是Happy path (滿意路徑)？根據維基，所謂的滿意路徑就是你在設計一個功能時預設使用者會使用的方式，而不考慮任何極端或錯誤的狀況。以這個計時器來說，happy path可以是： 使用者會輸入數字 =&gt; 這些數字就會成為秒數／分鐘 =&gt; 使用者按下開始，計時器開始倒數 =&gt; 計時器在倒數時邊框會隨著遞減 =&gt; 邊框跟著時間一起歸零。 而既然有happy path，相反的就有unhappy path。 unhappy path (不滿意路徑)一個計時器能夠有什麼好unhappy的？ 以原版計時器來說，unhappy path可以有以下幾個： 使用者輸入非數字（文字／符號） =&gt; 計時器產生NaN 使用者輸入小數點 =&gt; 在運作上沒什麼問題，可是這好像太過極端 使用者在按下開始後，又誤按下開始 =&gt; 計時器的倒數莫名的加速 使用者在倒數開始後，沒有按下暫停就又直接編輯輸入框 解決結合一開始提到的缺點，並考慮到不滿意路徑，我作了一些修正。 限制使用者輸入 這是一個很直觀的解法，就是從一開始就解決使用者可能亂輸入的問題。為了解決可能的NaN問題，我使用正則表達式禁止使用者輸入數字以外的字元（包括小數點），另外，由於我的版本新增分鐘，因此也在JS中限定輸入的邊界：若使用者輸入超過60秒，會自動轉為60秒。另外，若使用者沒有輸入值，或是輸入負數，會自動轉為0，避免任何不想要的值。 其實我一開始有考慮改用select，像ios的計時器一樣，但我總覺得直接輸入有一種說不出來的魅力……？ 開始計時後，封鎖一些按鈕 計時開始後，我將開始鈕、重設鈕、時間輸入框這些我不希望使用者亂碰的區域都設為disabled，以避免任何因前述原因導致的錯誤。主動限定使用者在計時開始後只能按下暫停。 新增變數以及輸入框監測 在原版中只使用了一個變數來儲存時間，導致了計時器倒數中若按下暫停，再按下開始時邊框的錯誤。這個問題困擾我最久，最後的解法是：我使用兩個變數，一個儲存設定的時間，一個儲存剩下的時間。另外，不管有沒有按下重設，使用者編輯輸入框時，設定的時間都會重新計算。主要的目標就是：讓整個流程變得更嚴謹。 感想我認為，嚴謹的定義每個流程，是解決不滿意路徑時的中心思想，在什麼時機，使用者要做什麼，這個「什麼」是否有一個清楚的答案？有了答案，才會知道錯誤是什麼。不過，在開始動手的時候我肯定是沒有想到這麼多的，最開始時我也只是想新增一些功能而已，這些都是不斷驗證不斷校正得出的理論。 我滿喜歡這堂課的，接下來還有很多實作項目，超級期待！","link":"/2020/03/07/timer-and-happy-path/"},{"title":"Vuex官方文檔閱讀筆記","text":"最近要使用Vuex，但是用得很不順手，因此一邊閱讀官方文檔一邊做個紀錄。（這個綠好好看喔） 什麼是Vuex？Vuex的核心概念就是一個倉庫，存儲專案中的資料狀態。Vuex中的儲存是響應式的，也就是說當其他元件讀取store中的狀態時，若是store中產生變化，相應的元件也會更新。 store中的狀態是不可以直接被改變的，只能透過提交（commit）Mutation的方式。 簡易的倉庫(store)使用方式vuex起手式npm install --save vuex 全域註冊元件 main.jsimport Vuex from 'vuex'Vue.use(Vuex) 在src中新增一個資料夾叫store，新增一個檔案叫index.js，這裡會彙整所有Vuex所有行為 index中也需要import vue &amp; vuex index.js 1234567import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store({ }); index.js載入main.js中main.js 12345678910111213import store from './store'//some codenew Vue({ el:'#app', router, /*****/ store, /*****/ components:{App}, template:'&lt;App/&gt;'}) 創建一支檔案管理store也可以放在一個額外的資料夾中store/index.js 12345678910111213import Vue from 'vue'import Vuex from 'vuex'const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }}) 如何在元件中取用store在根實例中新增，所有元件皆可取用store 12345new Vue({ el:'#app', //注入vuex的store store}) 在元件中取用 - 使用this.$store前綴 在某元件中提交mutation，改變store中的資料狀態 1234567methods:{ increment(){ //提交mutation this.$store.commit('increment'); console.log(this.$store.state.count); }} store內的交互關係 *資料來源: 六角學院 Vue出一個電商網站 核心觀念 - State使用Vuex是為了更好的追蹤資料的狀態變化，但是將所有資料一股腦丟進state中並不是最好選擇。若是元件內有專屬且必要的資料，就把它保留在元件中就好。 StateState類似Vue實例中的data屬性，他底下的資料必須是純值或是只含有純值屬性的物件。 如何在元件中取用state內的資料？使用computed-計算屬性來回傳store中的資料，若是store中資料有更新，computed就會重新更新。 元件內調用state 123456computed:{ count(){ //取用store return this.$store.state.count; }} 輔助函數 - mapState若是需要使用計算屬性取用多個state資料，與其在computed內新增多個函式來回傳，可以使用mapState 元件內 123456789101112131415161718192021222324//取用mapStateimport { mapState } from 'vuex';//寫法1 - 物件寫法computed: mapState({ //state為必須 count: state =&gt; state.count})//寫法2 - 若是要使用的計算屬性跟state的資料名稱一樣computed: mapState([ 'count' //this.count 為this.$store.state.count])//寫法3 - 與元件內其他計算屬性混用，展開物件屬性computed:{ localComputed(){ return something }, ...mapState({ count: state =&gt; state.count })} 核心觀念 - Gettersstore中的計算屬性，若是我們需要對state中的某個資料做出一些調整後再使用，就可以使用Getter。假使我們今天在做一個todolist，我們想要呈現列表中已完成的項目，我們會需要先過濾todos陣列，過濾出done屬性為true的項目再呈現，通常我們會在元件中使用computed屬性來完成。但是假設有很多元件都需要使用到這個「已完成列表」的資料，那就可以把原始的todos陣列存在state中，然後使用store中的Getter，先過濾出來，再在各元件中使用。 跟computed類似，getters只有在它依賴的資料發生改變時才會被重新觸發。 使用getters接收的第一個參數固定為state store/index.js 1234567891011121314const store = new Vuex.Store({ state: { todos: [ { id: 1, text: '...', done: true }, { id: 2, text: '...', done: false } ] }, getters: { //取出已經完成的 doneTodos: state =&gt; { return state.todos.filter(todo =&gt; todo.done) } }}) 在元件中取用某元件內 1store.getters.doneTodos // -&gt; [{ id: 1, text: '...', done: true }] getter也可以接受其他getter作為參數 1234567store/index.jsgetters:{ //第二個參數為store的getter countDoneTodos: (state, getter)=&gt;{ return getter.doneTodos.length; }} 元件中使用 12345computed:{ doneTodosCount(){ return this.$store.getters.countDoneTodos }} 使用閉包來傳入外部參數給getter 若是想要在state內資料中進行搜尋（標題／作者／某些屬性……，這裡的範例使用搜尋id），就可以使用這招 store/index.js 123456getters:{ //ES6寫法 getTodoById:(state) =&gt; (id) =&gt;{ return state.todos.find(todo =&gt; todo.id === id) }} 元件中使用 1this.$store.getters.getTodoById(2) //// -&gt; { id: 2, text: '...', done: false } 輔助函數 - mapGetters元件內 12345678910import { mapGetters } from 'vuex'//元件內computed:{ //其他計算屬性 ...mapGetters([ 'doneTodosCount', 'anotherGetter' ])} 然後就可以做為一般computed屬性使用 若是想將getter屬性在元件中另外取名，就使用物件 123...mapGetters({ doneCount: 'doneTodosCount'}) 資料來源Vuex官方文檔六角學院 - Vue出一個電商網站","link":"/2020/05/13/vuex-note/"}],"tags":[{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"troubleshoot","slug":"troubleshoot","link":"/tags/troubleshoot/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"六角鼠年全馬挑戰賽","slug":"六角鼠年全馬挑戰賽","link":"/tags/%E5%85%AD%E8%A7%92%E9%BC%A0%E5%B9%B4%E5%85%A8%E9%A6%AC%E6%8C%91%E6%88%B0%E8%B3%BD/"},{"name":"演算法","slug":"演算法","link":"/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Leaflet","slug":"Leaflet","link":"/tags/Leaflet/"},{"name":"口罩api","slug":"口罩api","link":"/tags/%E5%8F%A3%E7%BD%A9api/"},{"name":"bootstrap","slug":"bootstrap","link":"/tags/bootstrap/"},{"name":"作品心得","slug":"作品心得","link":"/tags/%E4%BD%9C%E5%93%81%E5%BF%83%E5%BE%97/"},{"name":"VeeValidate3","slug":"VeeValidate3","link":"/tags/VeeValidate3/"},{"name":"函式","slug":"函式","link":"/tags/%E5%87%BD%E5%BC%8F/"},{"name":"正規表達式","slug":"正規表達式","link":"/tags/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E9%81%94%E5%BC%8F/"},{"name":"Vuex","slug":"Vuex","link":"/tags/Vuex/"},{"name":"閱讀筆記","slug":"閱讀筆記","link":"/tags/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/"}],"categories":[{"name":"Daily Algorithm","slug":"Daily-Algorithm","link":"/categories/Daily-Algorithm/"},{"name":"六角鼠年全馬挑戰賽","slug":"六角鼠年全馬挑戰賽","link":"/categories/%E5%85%AD%E8%A7%92%E9%BC%A0%E5%B9%B4%E5%85%A8%E9%A6%AC%E6%8C%91%E6%88%B0%E8%B3%BD/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}