{"pages":[{"title":"about","text":"從2019年的九月開始自學前端技術，在這裡紀錄一些學習的心得。最重要的是：要記得寫！！！","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"npm指令無法運作","text":"發現問題剛剛正打算繼續寫vue的專案時，要運行伺服器而在終端機使用npm run serve指令時，突然跳出沒看過的錯誤： 123npm : 無法辨識 'npm' 詞彙是否為 Cmdlet、函數、指令檔或可執行程式的名稱。請檢查名稱拼字是否正確，如果包含路徑的話，請確認路徑是否正確，然後再試一次。位於 線路:1 字元:1 接著我在cmd中也試了vue ui指令，也跳錯 1'node' 不是內部或外部命令、可執行的程式或批次檔 / 解決 'node' 不是內部或外部命令，也不是可運行的程序 到底是……！？ 解決四處搜尋了一下，似乎是環境變數跑掉了，讓電腦找不到要執行的檔案。若你也遇到類似問題，可以跟著接下來的步驟。 1.先到控制台，打開系統 2.找到進階系統設定 3.打開之後，選取環境變數 4.要處理的是下方系統變數中的Path 5.設定路徑由於這次我的npm, nodejs, git都出問題，所以把這些安裝後的路徑都填進去 或是你也可以自己輸入這些路徑，不過不同的路徑間要記得用個分號；隔開 6.按下確定後測試一下，總算解決了 ### 為什麼會發生這個問題，我四處搜尋了下，好像都沒有人知道。不過我今天在剛開電腦時跳出git更新，然後就發生這個災難了。不知道有沒有關聯呢？","link":"/2020/02/02/2020-02-02/"},{"title":"JS - BMI計算機","text":"DEMO 目標用JavaScript做一個BMI計算機，而且可以顯示過往的測驗結果。這次一邊整理筆記一邊改寫，將當初很多段重複又累贅的地方重寫，心中很感慨，原來我也是有進步的。 預覽 難點：1.顯示結果的圓圈會根據結果數字的狀態變色2.列表的顏色也要跟著變 思考流程：1.先製作一個介面，使用者可以在相應的欄位輸入身高體重，然後按下結果按鈕 2.使用js計算使用者輸入的資料，並且將這些資料以物件的形式，儲存成一個陣列來管理。 3.這個陣列的資料同時也會儲存進local storage中，不過會是以字串的形式 4.處理完的BMI結果會呈現在欄位右方的圓圈，還有BMI狀態。 5.底下會生成一個相應的列表，記載BMI指數, BMI狀態、身高、體重、檢測日期。圓圈以及列表都會根據BMI狀態改變顏色 6.頁尾 7.結果圓圈的右下方有一個重新施測的紐，我想讓它活潑一點，所以想加一個旋轉的小動畫 8.我想要限制列表的數量，讓它不要過長。超過十五筆的話，就從最早的那一條開始刪掉。 9.我想讓列表從最新一筆紀錄開始呈現，而不是最後一筆 10.我想讓中間的列表在使用者第一次打開網頁時隱藏起來，當有紀錄時才開啟 開始動手作1.先製作一個介面，使用者可以在相應的欄位輸入身高體重，然後按下結果按鈕我將網頁分成三個部分，第一個是欄位區，叫header，中間要放檢測紀錄，就叫history，最後是頁尾，就叫footer。 先分好之後，就開始製作欄位。考慮到這個區塊的各個元素要相互對齊，我新增一個div區塊叫做cal，將這個區塊的display設定成flex，然後使用以下語法: 12align-items: center;justify-content: space-evenly; 我之前常常搞不清楚Items和content的區別，為了以防忘記．在這裡寫起來itemsalign - items和justify-items只能作用於單行 content若有多行元素時，就應使用align-content / justify-content 然後，要記得，flex這個屬性必須掛在外容器上!flexbox參考網頁 接下來，因為需要用到js抓取輸入的資料，各個輸入欄位我都下了不同的class，之後按鈕也要做變化，所以也先下了一個class。 1234567var height = document.querySelector(\".height\"); //使用者身高var weight = document.querySelector(\".weight\"); //使用者體重var resultBtn = document.querySelector(\".result-btn\"); //結果按鈕var list = document.querySelector(\".list\"); //歷史列表var his = document.querySelector(\".history\"); //要呈現列表的區塊//有了class，就可以抓取DOM元素，進行接下來JS的操作。 2.使用js計算使用者輸入的資料，並且將這些資料以物件的形式，儲存成一個陣列來管理。為了要儲存並且更好管理將來的資料，我先宣告一個陣列： 12//若是資料庫中有資料，就轉成物件存進Data, 若沒有就創造一個空陣列var data = JSON.parse(localStorage.getItem(\"BMIlist\")) || []; 這個陣列會從資料庫獲得資料，然後把資料轉化成物件儲存在自己裡面。為什麼不能直接宣告空陣列呢？因為我希望使用者在第二次第三次打開這個網頁時，都能看到自己以前的紀錄，所以要讀取資料庫的資料。這個陣列中的物件，我計劃要有以下的屬性： BMIstatus（BMI狀態）, BMIindex(BMI指數), height, weight, time, color 接下來是計算使用者資料。我寫了一個function。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function calculate(e){ //data陣列中的各個屬性處理 //1. 身高, 體重, BMI結果 var h = parseInt(height.value)/100; var w = parseInt(weight.value); var result = w/(h*h); result = result.toFixed(2); console.log(result); var status = \"\"; var color = \"\"; switch (true){ case result &lt;= 18.5: status = \"過輕\"; color = \"#31baf9\"; break; case 18.5 &lt; result &amp;&amp; result &lt;=25: status = \"理想\" color = \"#86d73f\"; break; case 25 &lt; result &amp;&amp; result &lt;=30: status = \"過重\"; color = \"#ff982d\"; break; case 30 &lt; result &amp;&amp; result &lt;=35: status = \"輕度肥胖\"; color = \"#ff6c03\"; break; case 35 &lt; result &amp;&amp; result &lt;=40: status = \"中度肥胖\"; color = '#ff6c03'; break; case 40 &lt; result: status = \"重度肥胖\" color = \"#ff1200\"; break; default: alert('資料有誤'); break; } //獲得當前日期 var date = new Date(); var day = date.getDate(); var month = date.getMonth()+1; var year = date.getFullYear(); //將計算出的資料存入一個物件中 var BMIdata = { height:h, weight:w, BMI:result, BMIstatus: status, time: month + \"-\" + day + \"-\" + year, color: color,}; //將最新的資料插入陣列中第一個，讓列表能從最新一筆開始 data.splice(0, 0, BMIdata); //將新的BMIdata(物件)存進data updateList(data); localStorage.setItem(\"BMIlist\", JSON.stringify(data)); if(data.length &gt; 15){ clear();}; switchBTN();} 一點小提醒：1.我發現如果不寫parseInt的話，height.value傳進來的會是字串而不是數字（我想是因為，.value本來就是抓取文字欄位元素的關係），為了保險起見，兩個需要傳入的變數我都加上parseInt。順帶一提，parseInt是將字串轉換為數字的一個function。 2.為了讓數字容易運算，結果看起來乾淨漂亮，我在result的數字做了toFixed(2)的處理－讓落落長的數字取到剩下小數點後兩位。 3.switch case的使用：原本我以為只能在有特定值時才可以使用，但其實換個角度想 1234if(result &lt;= 18.5){ status = \"過輕\"; color = \"#31baf9\"; } 這個意思不就代表 當result &lt;=18.5這個表達式 === true嗎？所以可以改寫為 1234switch(true){ case result &lt;= 18.5: //some action} 如此一來，物件中的BMIstatus, BMIindex, height, weight都有了，差一個time 在js中要取得當前時間，必須這樣寫： 12345//獲得當前日期 var date = new Date(); var day = date.getDate(); //取得日期 var month = date.getMonth()+1; //取得月份 var year = date.getFullYear(); //取得年分 要先呼叫一個新的Date物件，然後就可以使用下面幾個函示來取得你想要的內容。對了，getMonth()中，月份的計算是從0開始，一月（0)到十二月(11)，所以要是你想要正確的數字的話，你應該要記得加一。（那為什麼日期不也從0開始……？） 12345678var BMIdata = { height:h, weight:w, BMI:result, BMIstatus: status, time: month + \"-\" + day + \"-\" + year, color: color, }; 把物件中的各屬性配上之前寫的變數。 順帶一提，為了避免使用者沒有填入數字或是只寫零，我又加了一個function。 123456789101112resultBtn.addEventListener(\"click\", check); //按下按鈕後，先檢查是否有輸入數字，或是是否有輸入0，無前述狀況再執行計算function check(e){ if(height.value == \"\" || weight.value ==\"\"||height.value ==0 || weight.vaue == 0){ alert(\"數字不正確\"); } else{ calculate(height.value, weight.value); }};//使用者送出的資料會先跑進這個Function裡檢查有沒有零或是根本沒有填入，若是如此就會跳出一個提醒，若是都有填數字就會開始計算 3.這個陣列的資料同時也會儲存進local storage中，不過會是以字串的形式處理好陣列後，我們要來把它新增進資料庫中 1calStorage.setItem(\"BMIlist\", JSON.stringify(data)); 在資料庫中新增一個叫做BMIlist的欄位，把data陣列中的物件字串化後傳進去。這樣一來，當function calculate把資料都計算完，並且把資料儲存進陣列時，資料庫也會一起被更新。 4.底下會生成一個相應的列表，記載BMI指數, BMI狀態、身高、體重、檢測日期。圓圈以及列表都會根據BMI狀態改變顏色 我在做的時候，因為感覺旁邊的結果圓圈比較難，所以先從列表開始做。我寫了一個Function來處理這件事，這個function叫做updateList(data)，括號中間的data實際上跟上面提到的data陣列是不同的東西，之後我們還要再呼叫一次這個Function並且在括號中傳入data陣列。我只是想提醒我自己接下來要傳進去的是什麼東西。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function updateList(data){ //先抓取資料庫中資料 str = \"\"; //跑迴圈, 對每一個data中的元素都做處理 for(var i=0; i&lt; data.length; i++){ his.style.display = \"block\"; let text = ''; //使用一個template function來統一處理html function template(item){ return text =`&lt;li data-num =${i} class = listItem style = 'border-left: 7px ${data[i].color} solid'&gt;&lt;div class = 'BMIstatus'&gt;&lt;span style = 'font-size: 20px'&gt; ${data[i].BMIstatus}&lt;/span&gt;&lt;/div&gt;&lt;div class = 'result'&gt;BMI &lt;span style = 'font-size :20px; margin-left: 10px'&gt;${data[i].BMI}&lt;/span&gt;&lt;/div&gt;&lt;div class = 'weight-kg'&gt;weight&lt;span style = 'font-size :20px;margin-left: 10px'&gt;${data[i].weight}kg&lt;/span&gt;&lt;/div&gt;&lt;div class = 'height-cm'&gt;height&lt;span style = 'font-size :20px; margin-left: 10px'&gt;${data[i].height*100}cm&lt;/span&gt;&lt;/div&gt;&lt;div class = 'test-date'&gt;${data[i].time}&lt;/div&gt;&lt;/li&gt;` } //抓取陣列資料，根據抓到資料的bmistatus分類並列表 switch (data[i].BMIstatus){ case \"過輕\": template(data[i]); break; case \"理想\": template(data[i]); break; case \"過重\": template(data[i]); break; case \"輕度肥胖\": template(data[i]); break; case \"中度肥胖\": template(data[i]); break; case \"重度肥胖\": template(data[i]); break; default: alert('something is wrong!'); break; } str += text; }; list.innerHTML = str;}; 在這邊最重要的做法就是，使用innerHTML來把新增的列表元素加進ul列表中。所以我先設定一個空字串（str）的變數，在跑接下來的迴圈時，會依序加進相應的內容，最後再將這個字串變成html元素塞進ul列表中。 這樣一來，列表就完成了！這個function被放在程式碼最上面（因為我希望使用者一打開網頁時就能出現列表），還有Calculate函式中（這樣有新的資料傳進資料庫時，列表就能馬上更新）。 5. 我想要限制列表的數量，讓它不要過長。超過十五筆的話，就從最早的那一條開始刪掉。列表完成之後，在測試時發現，要是一直增加資料而沒有一個限制的話，列表就會變的落落長。要避免這件事，我決定限制陣列的長度，寫了一個function 123456789 if(data.length &gt; 15){ clear(); };function clear(){ for(var i=0; i&lt; data.length; i++){ data.splice(i, 1); }; localStorage.setItem(\"BMIlist\", JSON.stringify(data));} clear的功能是，把陣列的元素都跑一遍後，從最後那一筆刪掉一筆，然後用修剪過的陣列再更新一次資料庫。之後當陣列大於15時，就呼叫這個函式，把陣列修剪掉。看到這裡你可能覺得很奇怪，把最後那一筆刪掉的話，不就等於把最新的那筆資料刪掉嗎？這一步驟跟下一步驟環環相扣，請看： 6.我想讓列表從最新一筆紀錄開始呈現，而不是最後一筆網頁在這一步已經完成了有七成了吧。看著列表都能一一出現我已經很滿意，但是因為列表是由陣列的0~14開始跑，我想一想覺得不太對勁：最新的資料卻要滑到最下面才能看到，不是很不方便嗎？ 為了解決這個問題，我一開始的解法是使用data.reverse()反轉陣列。讓最後一筆能夠成為陣列第一筆。結果我發現，因為有許多function都在執行這個陣列，一邊反轉的話，另一邊就會出錯。 最後，我發現事情可以不用這麼複雜。 12data.splice(0, 0, BMIdata); splice( x, y, item) x是你想插入的位置，y是你想從那位置之後刪掉的資料數目，item是你想插進去的資料。使用splice，讓新的資料從第零筆插入，成為第零筆就好，最後一筆成為第一筆，原本的倒數第二成為第二筆，如此往後推進。也因此在上一步驟中的迴圈，我把最後一筆刪掉，其實也等於是把最早的刪掉。 其實我在這裡犯過不少愚蠢的錯…… 7.處理完的BMI結果會呈現在欄位右方的圓圈，還有BMI狀態。不知道為什麼，我一直很害怕這個部分，所以我拖到很後面才做。這一步中，我們要把原本的結果按鈕刪掉，然後新增一個會變色的圓圈圈，圈圈中間有BMI指數，還有一個重新開始的小按鈕，圓圈旁邊跟著一段顯示結果的文字。 先寫一個function，叫做switchBTN(){} 接著來刪掉原本的按鈕。 1234var getParent = resultBtn.parentNode;getParent.removeChild(resultBtn);var div = document.createElement(\"div\");div.setAttribute(\"class\", \"show\"); 我先取得按鈕的父元素（ParentNode），然後移除按鈕（remoceChild），接著新增一個div元素，給他一個Class名稱（我已經預先在css中設定好外觀了）。 接下來，因為這個圓圈有一些必須隨著資料變動的要素，所以就再跑一次迴圈，抓取各元素中的特定值（我要找的是bmi指數以及狀態） 接下來主要分兩部分，先寫個函式把接下來會重複的動作統一處理 1234567891011121314151617181920//這個函式其實一直在做一樣的事, 就是根據傳進來的資料, 還有這筆資料的各種屬性來渲染不同的htmlfunction btnHandle(item){ str = \"&lt;p &gt;\"+item.BMI+\"&lt;/p&gt;&lt;p style = 'font-size: 14px;'&gt;BMI&lt;/p&gt;&lt;a href = 'index.html'&gt;&lt;/a&gt;\"; div.innerHTML = str; div.style.color = item.color; div.style.border = `5px solid ${item.color}`; div.style.position = \"relative\"; var a = div.querySelector(\"a\"); a.style.backgroundColor = item.color; getParent.appendChild(div); //將str的字串新增到div元素中，設定css樣式 var p = document.createElement(\"div\"); p.setAttribute(\"class\", \"statusText\") var pStr = `&lt;p&gt; ${item.BMIstatus}&lt;/p&gt;` p.innerHTML = pStr; p.style.color = item.color; div.appendChild(p); } 然後是條件判斷 12345678910111213141516171819202122232425262728switch (data[0].BMIstatus){ case \"過輕\": btnHandle(data[0]); break; case \"理想\": btnHandle(data[0]); break; case \"過重\": btnHandle(data[0]); break; case \"輕度肥胖\": btnHandle(data[0]); break; case \"中度肥胖\": btnHandle(data[0]); break; case \"重度肥胖\": btnHandle(data[0]); break; default: alert('something is wrong!'); break; } 這個功能基本上就完成了。在這裡的做法跟做列表有點像，都使用到一個把字串塞進空字串中，然後創造html元素的做法。不過在這裡我沒有跑for迴圈，而是用switch來判斷當下的狀態，因為前面我把最新的資料都變成第零筆，所以我只要判斷第零筆的BMI狀態就好。 舉上面的例子，假如第零筆（也就是最新這一筆）的BMI狀態是過輕的話，我就在str中放進兩個p段落（一個是指數，一個是小小的bmi字樣）和一個a連結（重新開始的按鈕），這幾個元素的外觀我都在css中設定好了。 把str的HTML元素用innerHTML的方法設定好之後，接下來是根據該狀態來變更顏色。想要用js變更css樣式的話，就先把要變更的元素抓取過來，然後加上.style.color/ .border/….等等css語法。a連結也設定好之後，使用appendChild把這些新增好的元素加進剛剛的Parent node之下，就可以了。 別忘了，還有旁邊的狀態要寫！ 8.頁尾頁尾只有一個Logo要放，但是原本給的logo是透明的，不是這個顏色。我使用了css中的filter來調整，可以上codepen找css filter。 9.結果圓圈的右下方有一個重新施測的紐，我想讓它活潑一點，所以想加一個旋轉的小動畫123456789101112131415161718.show a:hover{ animation: spin 1.5s infinite; transition: ease;}/* 讓按鈕活潑 */@keyframes spin{ 0%{ 動畫的第０格時 transform: rotate(0); } 50%{ 動畫的中間 transform: rotate(360deg); } 100%{ 動畫的結尾 transform: rotate(360deg); }} 我想做的是：圖案旋轉一圈後，停止一下，再開始新的loop。除了要把iteration設定成infinite(無限)之外，因為要有間隔，所以50%和100%時做的是一樣的事，讓它停在原地。 10.我想讓中間的列表在使用者第一次打開網頁時隱藏起來，當有紀錄時才開啟到這裡網頁都完成了，但是當使用者第一次打開這個網頁時，中間的history區域因為沒有內容，會一片空白，我覺得這樣很奇怪，所以想要先把它隱藏起來，等到有資料進入時再出現。 沒想到我在這裡也花了很久！ 我一開始的做法是：把history區塊整個刪掉，先做條件判斷（當Data的長度&gt;=1時)，然後再一一新增回來。但是因為data有兩筆時也會大於一，有三筆時也會大於一，也就是說，只要有新的資料傳進來，這個條件判斷就會永遠成立，那就等於沒有用了！ 最後才靈光一閃 his.style.display = &quot;none&quot;; 我在程式馬最上面加了這一行，代表：「在網頁打開時，history列表是關起來的」，然後在updateList函式中，我才把它打開，這樣在生成列表的時候，history區塊也會跟著出現了。 心得其實距我做完這份作業已經過去幾個月了，那時候剛碰js，做得小心翼翼又戰戰兢兢的，還老是很悲觀地覺得我一定不行。能夠完成真的很開心！而且老實說，我那時的程式碼超冗長，哈哈，這次一邊整理筆記一邊改寫，將當初很多段重複又累贅的地方重寫，心中很感慨，原來我也是有進步的。算是在最近有些停滯又迷惘的日子提供一點新的動力。","link":"/2020/02/03/2020-02-03/"},{"title":"Vue - Vee Validate 3 操作方法","text":"目標因為六角的作業需要使用到Vee validate這個套件，可是課程內使用的第二版和目前第三版已經有所差距了，爬文也找不到相關資料，所以按照官網教學自己做了一次。 使用步驟1. 安裝安裝 npm install --save vee-validate 2. import進檔案中import有兩種方法，一種是在main.js中全局import，如此一來所有元件都能使用，還有一種是在要使用的元件中局部import 2.1 全局import123456//位置:main.js (你的vue專案中的進入點)//引入import { ValidationProvider } from 'vee-validate';//啟用Vue.component('ValidationProvider', ValidationProvider); 全局引用後不用在元件中再次引用就可以直接使用了 2.2 局部引用12345678910//位置：你在使用的元件名稱.vueimport { ValidationProvider } from 'vee-validate';export default {//區域元件註冊 components: { ValidationProvider }}; 3.使用vee validate的標籤validationprovider就如同vue註冊後的元件一樣，元件的名稱就會是html標籤，validation provider就是我們要使用的標籤 123456 &lt;validation-provider rules='email' v-slot='{errors}'&gt; 包住 &lt;input type=\"text\" v-model='form.user.email'&gt; &lt;span&gt;{{errors[0]}}&lt;/span&gt; //若輸入有誤時這裡將會跳出錯誤提示 包住&lt;/validation-provider&gt; HTML無法偵測大小寫, 所以使用kebab寫法 使用validation-provider包住要驗證的input，按照需求綁定V-model，官方建議要有v-model讓套件能抓到要驗證的資料，但是你不想使用的話，也能使用prop方式 :value = value 到這時架構就完成了，不過我們還要綁定一些驗證規則(rule)，讓使用者輸入正確的資料。 4.增加驗證規則(rule)驗證規則就是你要規定這些input中必須輸入什麼樣的訊息，例如要填email的欄位就不能讓使用者填電話號碼。Vee validate其實已經內建好許多規則，但我們可以先來看看怎麼自訂規則。 （以下為全局註冊的做法，若你是在元件內註冊，你可以將這些操作換到該元件中） 4.1 引入extend12//位置:main.jsimport { extend } from 'vee-validate'; ##### 4.2 新增規則我們新增一個規則來驗證使用者是否輸入正數 (positive) 1234567891011//位置:main.js //規則名稱 //使用者輸入的值extend('positive', value =&gt; { //驗證條件: 符合的話為true，不作為 if(value &gt;= 0){ return true; };//若是使用者輸入零或是負數導致驗證條件為false, 跳出下列訊息//錯誤訊息: return '必須大於零';}); 4.3 綁定規則在剛剛的html標籤上加上rules link12345&lt;validation-provider rules='positive' v-slot='{errors}'&gt; &lt;input type=\"text\" v-model='form.user.email'&gt; 錯誤訊息 &lt;span&gt;{{errors[0]}}&lt;/span&gt;&lt;/validation-provider&gt; 註：想要套用多種規則時在這裡我們新增一個規則，規定使用者只能輸入偶數 12345678910111213extend('positive', value =&gt; { if(value &gt;= 0){ return true; }; return '必須大於零';});extend('even', value =&gt; { if(value %2 ===0){ return true; }; return '必須是偶數';}); html綁定方法只要在剛剛的positive規則旁邊，用一條直線再加上新的規則名稱就好 1234&lt;validation-provider rules='positive|even' v-slot='{errors}'&gt; &lt;input type=\"text\" v-model='form.user.email'&gt; &lt;span&gt;{{errors[0]}}&lt;/span&gt;&lt;/validation-provider&gt; 此時套用的兩個規則都會生效。 5. 引用vee validate中內建的規則－以email為例veevalidate中內建有許多規則，你可以到node_modules (套件安裝的地方) =&gt; vee validate =&gt; dist =&gt; rules中找到這裡我們以email為例 （以下仍以全域註冊的方式進行） 5.1 在main.js中引入內建的規則因為這裡只需要email，所以引入這個就好 12//位置:main.jsimport { email } from 'vee-validate/dist/rules'; 5.2 建立規則有兩種做法，分為預設訊息與自訂訊息 5.2.1 若你不需要自訂訊息的話，此時會使用預設的訊息 123// 註冊的名稱 該規則extend('email', email); 5.2.1 若你想要跳出自訂的錯誤提示 12345 //註冊的名稱extend('email', { ...email, message: '郵件地址不正確' //自訂的訊息}); 完成了！ 這篇文章使用了官方的教學文件，想要知道更深入的內容請到這邊","link":"/2020/02/12/2020-02-12/"},{"title":"口罩地圖開發心得","text":"前言口罩地圖 / Rita Ho原始碼 因應這次的疫情，政府在推行實名制口罩購買後有公開藥局口罩庫存的api，在六角的社團看到後就很有興趣，也馬上打開VSCODE來練習，沒想到中間撞牆多次，耗費許多時間，是看了卡斯柏老師的直播才找到方向。 這篇文章就總結一下開發過程中印象深刻或新學習的部分。 使用技術：ajax, vue, leaflet 多資料串接如上文所說，這次的口罩api是由政府公開的，若你也有興趣的話，可以到這裡這裡，格式是json。 接資料的過程並不難，所以不多說過程，感到困難的部分是，當基本功能都開發完後，我決定使用’geolocation’ in navigators來偵測使用者位置並取得使用者附近的藥局。 使用geolocation時，我忽略了接取這個資料的過程也需要時間，我原本使用另一個函式來做資料接到後的處理，並放在vue的mounted hook，結果就是處理資料的函式先被執行，但要被處理的資料根本還沒來。 注意到這個時間差後，最後我採用的是promise這個方法。 12345678910111213141516171819202122232425//取得使用者位置let getUser = () =&gt; { return new Promise((resolve, reject) =&gt; { // return promise if (\"geolocation\" in navigator) { navigator.geolocation.getCurrentPosition(pos =&gt; { let lng = pos.coords.longitude; let lat = pos.coords.latitude; resolve([lng, lat]); this.user.userStat = true; }); } else { this.user.userStat = false; } }); }; //api資料 this.$http.get('https://raw.githubusercontent.com/kiang/pharmacies/master/json/points.json').then((res)=&gt;{ this.data = res.data.features }).then(getUser).then((data)=&gt;{ //取得使用者位置後再做下列行為 this.user.coords = data; this.flyToUser(); this.getNearby(); }); 在ajax部分，我同時使用到口罩的api和geolocation，這兩者在取得資訊速度也不相同，由於我會需要計算與使用者距離的函式，就勢必要確定兩者都取到資料後再做動作，不然會出現錯誤，但也考慮到也許使用者會不想打開位置偵測，考量之後我就用上述的順序來連接資料串接的過程，如此一來就算沒有使用者位置網站也能運行。 關於promise的部分其實我是這次遇到困難才開始研究，也只是先用求有再求好的心態，因此還不算熟悉（當時也搞到凌晨兩點了……），我想上面的程式碼可能也有我沒注意到的錯誤吧。 Leaflet 套件leaflet是一個js的地圖套件，官網，我採用的地圖是openstreetmap也有人開發出與vue適配性更高的Vue2Leaflet。 其實只使用leaflet原始的套件也是可以的，我也不太清楚兩者會有什麼差。 這次是我第一次自己研究套件和官方文檔，但是礙於我的知識有限，有時候根本是有看沒懂，甚至我一開始自己設定地圖的時候，根本不知道程式碼要放在vue的哪個位置。慘。 這次的網站只運用了leaflet最基本的一些功能，但成果我已經很滿意了，以呈現地圖和使用者交互的方面來說，真的不輸google map，另外，openstreetmap的地圖也滿精確的。真的很感謝這些開源又推廣技術的偉大團隊們。 程式碼規劃以前寫程式碼的時候，總是想說先寫再說，有就好，結果回過頭來看寫了很多重複累贅的功能或模板，這些其實都能整合起來。不知道在哪看到的話：「如果發現自己在寫第二遍一樣的東西時，就代表程式碼需要重構(refractor)了」，這次開發時謹記在心，一旦發現現在寫的東西之前好像有類似的，就會研究怎麼重構他，因此這次的成品跟之前相比真的精簡很多，每個功能我自認也都有其存在的理由。也算是有所成長了吧。 不過，永遠都不能愛上自己寫的code!! (出處不明) 在資料結構的規劃上，這次也學習到很多，經過各方觀摩後，這次也嘗試多使用物件的形式來整理資料，也能讓程式碼精簡一些，好像能比較靈活的規劃資料了。 UI規劃這次的版型是自己刻的，也有兼顧響應式，我個人很滿意在PC端的表現，雙欄式讓資料很清楚易懂，但是以現在的社會來說，以手機瀏覽的比重較重，因此在考慮手機版時，我決定讓地圖先呈現，下滑後才是結果列表。一開始的考量是結果列表比較長，文字的地址和圖像的呈現相較起來，後者似乎比較切身易懂。 不過實際使用後，總覺得一開始使用者面對一堆標示可能會搞不清楚狀況。我看到有些人是設定列表隱藏，全螢幕地圖，但問題感覺沒有解決。 另外，由於這次口罩實名制購買的規定挺繁瑣，還有關於圖示的說明，文字量有些多，因此我也不打算放在頁面上，而是需要點擊問號方塊另外打開，不知道這樣的設計夠不夠清楚呢？ 總結以我自己來說，給自己這次的表現90分了，一開始瘋狂撞牆的時候真的很痛苦，質疑自己很多次，但我都沒有放棄，四處找資料找資源，本來我以為自己可能真的不適合，但是只要我不放棄就代表我還是喜歡這件事的，我很高興這次相信了自己。","link":"/2020/02/19/2020-02-19/"}],"tags":[{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"troubleshoot","slug":"troubleshoot","link":"/tags/troubleshoot/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"六角鼠年全馬挑戰賽","slug":"六角鼠年全馬挑戰賽","link":"/tags/%E5%85%AD%E8%A7%92%E9%BC%A0%E5%B9%B4%E5%85%A8%E9%A6%AC%E6%8C%91%E6%88%B0%E8%B3%BD/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"VeeValidate3","slug":"VeeValidate3","link":"/tags/VeeValidate3/"},{"name":"Leaflet","slug":"Leaflet","link":"/tags/Leaflet/"},{"name":"口罩api","slug":"口罩api","link":"/tags/%E5%8F%A3%E7%BD%A9api/"},{"name":"bootstrap","slug":"bootstrap","link":"/tags/bootstrap/"}],"categories":[{"name":"六角鼠年全馬挑戰賽","slug":"六角鼠年全馬挑戰賽","link":"/categories/%E5%85%AD%E8%A7%92%E9%BC%A0%E5%B9%B4%E5%85%A8%E9%A6%AC%E6%8C%91%E6%88%B0%E8%B3%BD/"}]}